{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetSum\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalFinsetSum</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt\">NormNumExt</a></div></div>","info":{"doc":"`norm_num` plugin for evaluating sums of finsets.\n\nIf your finset is not supported, you can add it to the match in `Finset.proveEmptyOrCons`.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetSum","kind":"def","line":384,"name":"Mathlib.Meta.NormNum.evalFinsetSum","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L384-L407"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetProd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalFinsetProd</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt\">NormNumExt</a></div></div>","info":{"doc":"`norm_num` plugin for evaluating products of finsets.\n\nIf your finset is not supported, you can add it to the match in `Finset.proveEmptyOrCons`.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetProd","kind":"def","line":355,"name":"Mathlib.Meta.NormNum.evalFinsetProd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L355-L381"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetBigop\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalFinsetBigop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span> → <span class=\"fn\"><span class=\"fn\">(<span class=\"fn\">«$α»</span> → <span class=\"fn\">«$β»</span>)</span> → <span class=\"fn\">«$β»</span></span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$α»</span> → <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res_empty</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <a href=\"./Mathlib/Data/Finset/Empty.html#Finset.empty\">Finset.empty</a> <span class=\"fn\">«$f»</span></span>)</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">res_cons</span> :\n  <span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>} →\n    <span class=\"fn\">{<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>} →\n      <span class=\"fn\">{<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a»</span> ∉ <span class=\"fn\">«$s'»</span></span>)</span>} →\n        <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$f»</span> <span class=\"fn\">«$a»</span></span>)</span></span> →\n          <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <span class=\"fn\">«$s'»</span> <span class=\"fn\">«$f»</span></span>)</span></span> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$s'»</span> <span class=\"fn\">«$h»</span>)</span> <span class=\"fn\">«$f»</span></span>)</span>)</span></span></span></span></span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">q(<span class=\"fn\"><span class=\"fn\">«$op»</span> <span class=\"fn\">«$s»</span> <span class=\"fn\">«$f»</span></span>)</span>)</span></span></div></div>","info":{"doc":"Evaluate a big operator applied to a finset by repeating `proveEmptyOrCons` until\nwe exhaust all elements of the set. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.evalFinsetBigop","kind":"opaque","line":333,"name":"Mathlib.Meta.NormNum.evalFinsetBigop","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L333-L352"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.prod_empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Finset</span>.<span class=\"name\">prod_empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.<a href=\"./Mathlib/Algebra/BigOperators/Group/Finset/Defs.html#Finset.prod\">prod</a></span> <span class=\"fn\">f</span>)</span> <span class=\"fn\">1</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.prod_empty","kind":"theorem","line":329,"name":"Mathlib.Meta.NormNum.Finset.prod_empty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L329-L331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.sum_empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Finset</span>.<span class=\"name\">sum_empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommSemiring\">CommSemiring</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">IsNat</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>.<a href=\"./Mathlib/Algebra/BigOperators/Group/Finset/Defs.html#Finset.sum\">sum</a></span> <span class=\"fn\">f</span>)</span> <span class=\"fn\">0</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Finset.sum_empty","kind":"theorem","line":325,"name":"Mathlib.Meta.NormNum.Finset.sum_empty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L325-L327"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Result.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">Result</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$b»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">b</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Result</a> <span class=\"fn\">a</span></span></span></div></div>","info":{"doc":"If `a = b` and we can evaluate `b`, then we can evaluate `a`. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.NormNum.Result.eq_trans","kind":"def","line":306,"name":"Mathlib.Meta.NormNum.Result.eq_trans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L306-L323"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.proveEmptyOrCons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">proveEmptyOrCons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span>)</span></span></div></div>","info":{"doc":"Either show the expression `s : Q(Finset α)` is empty, or remove one element from it.\n\nFails if we cannot determine which of the alternatives apply to the expression.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.proveEmptyOrCons","kind":"opaque","line":261,"name":"Mathlib.Meta.Finset.proveEmptyOrCons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L261-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.univ_eq_elems\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">univ_eq_elems</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Data/Fintype/Defs.html#Fintype\">Fintype</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elems</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">complete</span> : <span class=\"fn\">∀ (<span class=\"fn\">x</span> : <span class=\"fn\">α</span>), <span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">elems</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Data/Fintype/Defs.html#Finset.univ\">Finset.univ</a> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">elems</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.univ_eq_elems","kind":"theorem","line":256,"name":"Mathlib.Meta.Finset.univ_eq_elems","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L256-L259"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_succ'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">range_succ'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">nn </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">nn</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn'</span> : <span class=\"fn\">nn</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n'</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Range.html#Finset.range\">Finset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">n'</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Finset/Range.html#Finset.range\">Finset.range</a> <span class=\"fn\">n'</span>)</span> <span class=\"fn\">⋯</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_succ'","kind":"theorem","line":252,"name":"Mathlib.Meta.Finset.range_succ'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L252-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">range_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Range.html#Finset.range\">Finset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.range_zero'","kind":"theorem","line":249,"name":"Mathlib.Meta.Finset.range_zero'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L249-L250"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.insert_eq_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">insert_eq_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">a</span> ∉ <span class=\"fn\">s</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert.insert\">insert</a> <span class=\"fn\">a</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">a</span> <span class=\"fn\">s</span> <span class=\"fn\">h</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.insert_eq_cons","kind":"theorem","line":245,"name":"Mathlib.Meta.Finset.insert_eq_cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L245-L247"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s </span><span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$t»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span></span></div></div>","info":{"doc":"If `s = t` and we can get the result for `t`, then we can get the result for `s`.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans","kind":"def","line":237,"name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L237-L243"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">uncheckedCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">t</span></span></span></div></div>","info":{"doc":"If `s` unifies with `t`, convert a result for `s` to a result for `t`.\n\nIf `s` does not unify with `t`, this results in a type-incorrect proof.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast","kind":"def","line":227,"name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L227-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Q(<span class=\"fn\"><span class=\"fn\">«$a»</span> ∉ <span class=\"fn\">«$s'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Insert.html#Finset.cons\">Finset.cons</a> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$s'»</span> <span class=\"fn\">«$h»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"The set equals `a` inserted into the strict subset `s'`. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.cons","kind":"ctor","line":224,"name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L224-L225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.empty\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span>.<span class=\"name\">empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Core.html#EmptyCollection.emptyCollection\">∅</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\">ProveEmptyOrConsResult</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"The set is empty. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult.empty","kind":"ctor","line":222,"name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult.empty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L222-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Finset</span>.<span class=\"name\">ProveEmptyOrConsResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"This represents the result of trying to determine whether the given expression\n`s : Q(Finset $α)` is either empty or consists of an element inserted into a strict subset. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Finset.ProveEmptyOrConsResult","kind":"inductive","line":219,"name":"Mathlib.Meta.Finset.ProveEmptyOrConsResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L219-L225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.proveZeroOrCons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">proveZeroOrCons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span>)</span></span></div></div>","info":{"doc":"Either show the expression `s : Q(Multiset α)` is Zero, or remove one element from it.\n\nFails if we cannot determine which of the alternatives apply to the expression.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.proveZeroOrCons","kind":"def","line":187,"name":"Mathlib.Meta.Multiset.proveZeroOrCons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L187-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_succ'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">range_succ'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">nn </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">nn</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn'</span> : <span class=\"fn\">nn</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n'</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Range.html#Multiset.range\">Multiset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">n'</span> <a href=\"./Mathlib/Data/Multiset/ZeroCons.html#Multiset.cons\">::ₘ</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Range.html#Multiset.range\">Multiset.range</a> <span class=\"fn\">n'</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_succ'","kind":"theorem","line":183,"name":"Mathlib.Meta.Multiset.range_succ'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L183-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">range_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Range.html#Multiset.range\">Multiset.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.range_zero'","kind":"theorem","line":180,"name":"Mathlib.Meta.Multiset.range_zero'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L180-L181"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.insert_eq_cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">insert_eq_cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert.insert\">insert</a> <span class=\"fn\">a</span> <span class=\"fn\">s</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a</span> <a href=\"./Mathlib/Data/Multiset/ZeroCons.html#Multiset.cons\">::ₘ</a> <span class=\"fn\">s</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.insert_eq_cons","kind":"theorem","line":176,"name":"Mathlib.Meta.Multiset.insert_eq_cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L176-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s </span><span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$t»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span></span></div></div>","info":{"doc":"If `s = t` and we can get the result for `t`, then we can get the result for `s`.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans","kind":"def","line":168,"name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L168-L174"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">uncheckedCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">t</span></span></span></div></div>","info":{"doc":"If `s` unifies with `t`, convert a result for `s` to a result for `t`.\n\nIf `s` does not unify with `t`, this results in a type-incorrect proof.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast","kind":"def","line":158,"name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L158-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a»</span> <a href=\"./Mathlib/Data/Multiset/ZeroCons.html#Multiset.cons\">::ₘ</a> <span class=\"fn\">«$s'»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"The set equals `a` inserted into the strict subset `s'`. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.cons","kind":"ctor","line":155,"name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L155-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\">ProveZeroOrConsResult</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"The set is zero. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult.zero","kind":"ctor","line":153,"name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L153-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Multiset</span>.<span class=\"name\">ProveZeroOrConsResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Multiset/Defs.html#Multiset\">Multiset</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"This represents the result of trying to determine whether the given expression\n`s : Q(Multiset $α)` is either empty or consists of an element inserted into a strict subset. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Multiset.ProveZeroOrConsResult","kind":"inductive","line":150,"name":"Mathlib.Meta.Multiset.ProveZeroOrConsResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L150-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.proveNilOrCons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">proveNilOrCons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span>)</span></span></div></div>","info":{"doc":"Either show the expression `s : Q(List α)` is Nil, or remove one element from it.\n\nFails if we cannot determine which of the alternatives apply to the expression.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.proveNilOrCons","kind":"opaque","line":110,"name":"Mathlib.Meta.List.proveNilOrCons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L110-L148"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_succ_eq_map'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">range_succ_eq_map'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">nn </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">nn</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn'</span> : <span class=\"fn\">nn</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">n'</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/List/Basic.html#List.range\">List.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List.map\">List.map</a> <a href=\"./Init/Prelude.html#Nat.succ\">Nat.succ</a> <span class=\"fn\">(<a href=\"./Init/Data/List/Basic.html#List.range\">List.range</a> <span class=\"fn\">n'</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_succ_eq_map'","kind":"theorem","line":105,"name":"Mathlib.Meta.List.range_succ_eq_map'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L105-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_zero'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">range_zero'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/List/Basic.html#List.range\">List.range</a> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.range_zero'","kind":"theorem","line":102,"name":"Mathlib.Meta.List.range_zero'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L102-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.eq_trans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">eq_trans</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s </span><span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">eq</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$t»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span></span></div></div>","info":{"doc":"If `s = t` and we can get the result for `t`, then we can get the result for `s`.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.eq_trans","kind":"def","line":94,"name":"Mathlib.Meta.List.ProveNilOrConsResult.eq_trans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L94-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">uncheckedCast</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u </span><span class=\"fn\">v</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> v)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$β»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">t</span></span></span></div></div>","info":{"doc":"If `s` unifies with `t`, convert a result for `s` to a result for `t`.\n\nIf `s` does not unify with `t`, this results in a type-incorrect proof.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast","kind":"def","line":84,"name":"Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L84-L92"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.cons\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">cons</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s'</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$a»</span> <a href=\"./Init/Prelude.html#List.cons\">::</a> <span class=\"fn\">«$s'»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"The set equals `a` inserted into the strict subset `s'`. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.cons","kind":"ctor","line":81,"name":"Mathlib.Meta.List.ProveNilOrConsResult.cons","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L81-L82"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.nil\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span>.<span class=\"name\">nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\">Q(<span class=\"fn\">«$s»</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#List.nil\">[</a><a href=\"./Init/Prelude.html#List.nil\">]</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\">ProveNilOrConsResult</a> <span class=\"fn\">s</span></span></div></div>","info":{"doc":"The set is Nil. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult.nil","kind":"ctor","line":79,"name":"Mathlib.Meta.List.ProveNilOrConsResult.nil","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L79-L80"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">List</span>.<span class=\"name\">ProveNilOrConsResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"This represents the result of trying to determine whether the given expression\n`s : Q(List $α)` is either empty or consists of an element inserted into a strict subset. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.List.ProveNilOrConsResult","kind":"inductive","line":76,"name":"Mathlib.Meta.List.ProveNilOrConsResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L76-L82"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.unifyZeroOrSucc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">unifyZeroOrSucc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\">UnifyZeroOrSuccResult</a> <span class=\"fn\">n</span>)</span></span></div></div>","info":{"doc":"Determine whether the expression `n : Q(ℕ)` unifies with `0` or `Nat.succ n'`.\n\nWe do not use `norm_num` functionality because we want definitional equality,\nnot propositional equality, for use in dependent types.\n\nFails if neither of the options succeed.\n","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.unifyZeroOrSucc","kind":"def","line":59,"name":"Mathlib.Meta.Nat.unifyZeroOrSucc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L59-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.succ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">UnifyZeroOrSuccResult</span>.<span class=\"name\">succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\"><span class=\"fn\">«$n»</span> =Q <span class=\"fn\"><span class=\"fn\">«$n'»</span>.<a href=\"./Init/Prelude.html#Nat.succ\">succ</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\">UnifyZeroOrSuccResult</a> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"`n` unifies with `succ n'` for this specific `n'` ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.succ","kind":"ctor","line":56,"name":"Mathlib.Meta.Nat.UnifyZeroOrSuccResult.succ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L56-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.zero\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">UnifyZeroOrSuccResult</span>.<span class=\"name\">zero</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <span class=\"fn\"><span class=\"fn\">«$n»</span> =Q <span class=\"fn\">0</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\">UnifyZeroOrSuccResult</a> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"`n` unifies with `0` ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult.zero","kind":"ctor","line":54,"name":"Mathlib.Meta.Nat.UnifyZeroOrSuccResult.zero","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L54-L55"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Nat</span>.<span class=\"name\">UnifyZeroOrSuccResult</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"This represents the result of trying to determine whether the given expression `n : Q(ℕ)`\nis either `zero` or `succ`. ","docLink":"./Mathlib/Tactic/NormNum/BigOperators.html#Mathlib.Meta.Nat.UnifyZeroOrSuccResult","kind":"inductive","line":51,"name":"Mathlib.Meta.Nat.UnifyZeroOrSuccResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/BigOperators.lean#L51-L57"}}],"imports":["Init","Mathlib.Tactic.NormNum.Basic","Mathlib.Data.List.FinRange","Mathlib.Algebra.BigOperators.Group.Finset.Basic"],"instances":[],"name":"Mathlib.Tactic.NormNum.BigOperators"}