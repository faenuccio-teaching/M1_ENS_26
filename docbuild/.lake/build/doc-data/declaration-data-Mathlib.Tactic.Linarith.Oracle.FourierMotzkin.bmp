{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CertificateOracle</span>.<span class=\"name\">fourierMotzkin</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.CertificateOracle\">CertificateOracle</a></div></div>","info":{"doc":"An oracle that uses Fourier-Motzkin elimination. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin","kind":"def","line":361,"name":"Mathlib.Tactic.Linarith.CertificateOracle.fourierMotzkin","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L361-L369"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.mkLinarithData\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">mkLinarithData</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hyps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData\">LinarithData</a></div></div>","info":{"doc":"`mkLinarithData hyps vars` takes a list of hypotheses and the largest variable present in\nthose hypotheses. It produces an initial state for the elimination monad.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.mkLinarithData","kind":"def","line":354,"name":"Mathlib.Tactic.Linarith.mkLinarithData","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L354-L359"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimAllVarsM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">elimAllVarsM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"`elimAllVarsM` eliminates all variables from the linarith state, leaving it with a set of\nground comparisons. If this succeeds without exception, the original `linarith` state is consistent.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimAllVarsM","kind":"def","line":346,"name":"Mathlib.Tactic.Linarith.elimAllVarsM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L346-L352"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVarM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">elimVarM</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"`elimVarM a` performs one round of Fourier-Motzkin elimination, eliminating the variable `a`\nfrom the `linarith` state.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVarM","kind":"def","line":331,"name":"Mathlib.Tactic.Linarith.elimVarM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L331-L344"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.splitSetByVarSign\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">splitSetByVarSign</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a></div></div>","info":{"doc":"`splitSetByVarSign a comps` partitions the set `comps` into three parts.\n* `pos` contains the elements of `comps` in which `a` has a positive coefficient.\n* `neg` contains the elements of `comps` in which `a` has a negative coefficient.\n* `notPresent` contains the elements of `comps` in which `a` has coefficient 0.\n\nReturns `(pos, neg, notPresent)`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.splitSetByVarSign","kind":"def","line":315,"name":"Mathlib.Tactic.Linarith.splitSetByVarSign","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L315-L329"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.update\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">update</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Updates the current state with a new max variable and comparisons,\nand calls `validate` to check for a contradiction.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.update","kind":"def","line":307,"name":"Mathlib.Tactic.Linarith.update","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L307-L313"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.validate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">validate</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Throws an exception if a contradictory `PComp` is contained in the current state. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.validate","kind":"def","line":301,"name":"Mathlib.Tactic.Linarith.validate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L301-L305"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getPCompSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">getPCompSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\">LinarithM</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a></span></div></div>","info":{"doc":"Return the current comparison set. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getPCompSet","kind":"def","line":297,"name":"Mathlib.Tactic.Linarith.getPCompSet","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L297-L299"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getMaxVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">getMaxVar</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\">LinarithM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"Returns the current max variable. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.getMaxVar","kind":"def","line":293,"name":"Mathlib.Tactic.Linarith.getMaxVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L293-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithM</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./foundational_types.html\">Type</a> → <a href=\"./foundational_types.html\">Type</a></span></div></div>","info":{"doc":"The linarith monad extends an exceptional monad with a `LinarithData` state.\nAn exception produces a contradictory `PComp`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithM","kind":"def","line":286,"name":"Mathlib.Tactic.Linarith.LinarithM","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L286-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">comps</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData\">LinarithData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a></div></div>","info":{"doc":"The set of comparisons. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.comps","kind":"def","line":284,"name":"Mathlib.Tactic.Linarith.LinarithData.comps","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L284-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.maxVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">maxVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData\">LinarithData</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>","info":{"doc":"The largest variable index that has not been (officially) eliminated. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.maxVar","kind":"def","line":282,"name":"Mathlib.Tactic.Linarith.LinarithData.maxVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L282-L282"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">maxVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData\">LinarithData</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData.mk","kind":"ctor","line":280,"name":"Mathlib.Tactic.Linarith.LinarithData.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L280-L280"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">LinarithData</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The state for the elimination monad.\n* `maxVar`: the largest variable index that has not been eliminated.\n* `comps`: a set of comparisons\n\nThe elimination procedure proceeds by eliminating variable `v` from `comps` progressively\nin decreasing order.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.LinarithData","kind":"structure","line":272,"name":"Mathlib.Tactic.Linarith.LinarithData","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L272-L284"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimWithSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">elimWithSet</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">comps</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\">PCompSet</a></div></div>","info":{"doc":"`elimWithSet a p comps` collects the result of calling `pelimVar p p' a`\nfor every `p' ∈ comps`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimWithSet","kind":"def","line":262,"name":"Mathlib.Tactic.Linarith.elimWithSet","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L262-L270"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.isContr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">isContr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"A `PComp` represents a contradiction if its `Comp` field represents a contradiction.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.isContr","kind":"def","line":257,"name":"Mathlib.Tactic.Linarith.PComp.isContr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L257-L260"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.pelimVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">pelimVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p1 </span><span class=\"fn\">p2</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></span></div></div>","info":{"doc":"`pelimVar p1 p2` calls `elimVar` on the `Comp` components of `p1` and `p2`.\nIf this returns `v1` and `v2`, it creates a new `PComp` equal to `v1*p1 + v2*p2`,\nand tracks this in the `CompSource`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.pelimVar","kind":"def","line":248,"name":"Mathlib.Tactic.Linarith.pelimVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L248-L255"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">elimVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c1 </span><span class=\"fn\">c2</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>","info":{"doc":"If `c1` and `c2` both contain variable `a` with opposite coefficients,\nproduces `v1` and `v2` such that `a` has been cancelled in `v1*c1 + v2*c2`. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.elimVar","kind":"def","line":238,"name":"Mathlib.Tactic.Linarith.elimVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L238-L246"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PCompSet</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A collection of comparisons. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PCompSet","kind":"def","line":233,"name":"Mathlib.Tactic.Linarith.PCompSet","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L233-L234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToStringPComp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">instToStringPComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToStringPComp","kind":"instance","line":230,"name":"Mathlib.Tactic.Linarith.instToStringPComp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L230-L231"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatPComp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">instToFormatPComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatPComp","kind":"instance","line":227,"name":"Mathlib.Tactic.Linarith.instToFormatPComp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L227-L228"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.assump\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">assump</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></div></div>","info":{"doc":"`PComp.assump c n` creates a `PComp` whose comparison is `c` and whose source is\n`CompSource.assump n`, that is, `c` is derived from the `n`th hypothesis.\nThe history is the singleton set `{n}`.\nNo variables have been eliminated (effectively or implicitly).\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.assump","kind":"def","line":213,"name":"Mathlib.Tactic.Linarith.PComp.assump","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L213-L225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c1 </span><span class=\"fn\">c2</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elimVar</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></div></div>","info":{"doc":"`PComp.add c1 c2 elimVar` creates the result of summing the linear comparisons `c1` and `c2`,\nduring the process of eliminating the variable `elimVar`.\nThe computation assumes, but does not enforce, that `elimVar` appears in both `c1` and `c2`\nand does not appear in the sum.\nComputing the sum of the two comparisons is easy; the complicated details lie in tracking the\nadditional fields of `PComp`.\n* The historical set `pcomp.history` of `c1 + c2` is the union of the two historical sets.\n* `vars` is the union of `c1.vars` and `c2.vars`.\n* The effectively eliminated variables of `c1 + c2` are the union of the two effective sets,\n  with `elim_var` inserted.\n* The implicitly eliminated variables of `c1 + c2` are those that appear in\n  `vars` but not `c.vars` or `effective`.\n(Note that the description of the implicitly eliminated variables of `c1 + c2` in the algorithm\ndescribed in Section 6 of https://doi.org/10.1016/B978-0-444-88771-9.50019-2 seems to be wrong:\nthat says it should be `(c1.implicit.union' c2.implicit).sdiff explicit`.\nSince the implicitly eliminated sets start off empty for the assumption,\nthis formula would leave them always empty.)\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.add","kind":"def","line":185,"name":"Mathlib.Tactic.Linarith.PComp.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L185-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></div></div>","info":{"doc":"`PComp.scale c n` scales the coefficients of `c` by `n` and notes this in the `CompSource`. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.scale","kind":"def","line":181,"name":"Mathlib.Tactic.Linarith.PComp.scale","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L181-L183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p1 </span><span class=\"fn\">p2</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></div></div>","info":{"doc":"The `src : CompSource` field is ignored when comparing `PComp`s. Two `PComp`s proving the same\ncomparison, with different sources, are considered equivalent.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.cmp","kind":"def","line":175,"name":"Mathlib.Tactic.Linarith.PComp.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L175-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">maybeMinimal</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">elimedGE</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Any comparison whose history is not minimal is redundant,\nand need not be included in the new set of comparisons.\n`elimedGE : ℕ` is a natural number such that all variables with index ≥ `elimedGE` have been\nremoved from the system.\n\nThis test is an overapproximation to minimality. It gives necessary but not sufficient conditions.\nIf the history of `c` is minimal, then `c.maybeMinimal` is true,\nbut `c.maybeMinimal` may also be true for some `c` with non-minimal history.\nThus, if `c.maybeMinimal` is false, `c` is known not to be minimal and must be redundant.\nSee https://doi.org/10.1016/B978-0-444-88771-9.50019-2 (Theorem 13).\nThe condition described there considers only implicitly eliminated variables that have been\nofficially eliminated from the system. This is not the case for every implicitly eliminated\nvariable. Consider eliminating `z` from `{x + y + z < 0, x - y - z < 0}`. The result is the set\n`{2*x < 0}`; `y` is implicitly but not officially eliminated.\n\nThis implementation of Fourier-Motzkin elimination processes variables in decreasing order of\nindices. Immediately after a step that eliminates variable `k`, variable `k'` has been eliminated\niff `k' ≥ k`. Thus we can compute the intersection of officially and implicitly eliminated variables\nby taking the set of implicitly eliminated variables with indices ≥ `elimedGE`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.maybeMinimal","kind":"def","line":151,"name":"Mathlib.Tactic.Linarith.PComp.maybeMinimal","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L151-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">vars</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span></div></div>","info":{"doc":"The union of all variables appearing in those original assumptions\nwhich appear in the `history` set. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.vars","kind":"def","line":149,"name":"Mathlib.Tactic.Linarith.PComp.vars","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L149-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.implicit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">implicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span></div></div>","info":{"doc":"The variables which have been *implicitly eliminated*.\nThese are variables that appear in the historical set,\ndo not appear in `c` itself, and are not in `effective`. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.implicit","kind":"def","line":146,"name":"Mathlib.Tactic.Linarith.PComp.implicit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L146-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">effective</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span></div></div>","info":{"doc":"The variables which have been *effectively eliminated*,\ni.e. by running the elimination algorithm on that variable. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.effective","kind":"def","line":142,"name":"Mathlib.Tactic.Linarith.PComp.effective","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L142-L142"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">history</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span></div></div>","info":{"doc":"The set of original assumptions which have been used in constructing this comparison. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.history","kind":"def","line":139,"name":"Mathlib.Tactic.Linarith.PComp.history","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L139-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.src\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">src</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></div></div>","info":{"doc":"We track how the comparison was constructed by adding and scaling previous comparisons,\nback to the original assumptions. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.src","kind":"def","line":137,"name":"Mathlib.Tactic.Linarith.PComp.src","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L137-L137"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">c</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a></div></div>","info":{"doc":"The comparison `Σ cᵢ*xᵢ R 0`. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.c","kind":"def","line":134,"name":"Mathlib.Tactic.Linarith.PComp.c","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L134-L134"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.mk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span>.<span class=\"name\">mk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">c</span> : <a href=\"./Mathlib/Tactic/Linarith/Datatypes.html#Mathlib.Tactic.Linarith.Comp\">Comp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">src</span> : <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">history </span><span class=\"fn\">effective </span><span class=\"fn\">implicit </span><span class=\"fn\">vars</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">Std.TreeSet</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Data/Ord/Basic.html#Ord.compare\">compare</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\">PComp</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp.mk","kind":"ctor","line":132,"name":"Mathlib.Tactic.Linarith.PComp.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L132-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">PComp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A `PComp` stores a linear comparison `Σ cᵢ*xᵢ R 0`,\nalong with information about how this comparison was derived.\nThe original expressions fed into `linarith` are each assigned a unique natural number label.\nThe *historical set* `PComp.history` stores the labels of expressions\nthat were used in deriving the current `PComp`.\nVariables are also indexed by natural numbers. The sets `PComp.effective`, `PComp.implicit`,\nand `PComp.vars` contain variable indices.\n* `PComp.vars` contains the variables that appear in any inequality in the historical set.\n* `PComp.effective` contains the variables that have been effectively eliminated from `PComp`.\n  A variable `n` is said to be *effectively eliminated* in `p : PComp` if the elimination of `n`\n  produced at least one of the ancestors of `p` (or `p` itself).\n* `PComp.implicit` contains the variables that have been implicitly eliminated from `PComp`.\n  A variable `n` is said to be *implicitly eliminated* in `p` if it satisfies the following\n  properties:\n  - `n` appears in some inequality in the historical set (i.e. in `p.vars`).\n  - `n` does not appear in `p.c.vars` (i.e. it has been eliminated).\n  - `n` was not effectively eliminated.\n\nWe track these sets in order to compute whether the history of a `PComp` is *minimal*.\nChecking this directly is expensive, but effective approximations can be defined in terms of these\nsets. During the variable elimination process, a `PComp` with non-minimal history can be discarded.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.PComp","kind":"structure","line":109,"name":"Mathlib.Tactic.Linarith.PComp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L109-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatCompSource\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">instToFormatCompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instToFormatCompSource","kind":"instance","line":106,"name":"Mathlib.Tactic.Linarith.instToFormatCompSource","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L106-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">toString</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>","info":{"doc":"Formats a `CompSource` for printing. ","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.toString","kind":"def","line":100,"name":"Mathlib.Tactic.Linarith.CompSource.toString","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L100-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">flatten</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a> → <span class=\"fn\"><a href=\"./Std/Data/HashMap/Basic.html#Std.HashMap\">Std.HashMap</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></div></div>","info":{"doc":"Given a `CompSource` `cs`, `cs.flatten` maps an assumption index\nto the number of copies of that assumption that appear in the history of `cs`.\n\nFor example, suppose `cs` is produced by scaling assumption 2 by 5,\nand adding to that the sum of assumptions 1 and 2.\n`cs.flatten` maps `1 ↦ 1, 2 ↦ 6`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.flatten","kind":"def","line":86,"name":"Mathlib.Tactic.Linarith.CompSource.flatten","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L86-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">instInhabitedCompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource","kind":"instance","line":84,"name":"Mathlib.Tactic.Linarith.instInhabitedCompSource","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L84-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource.default\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">instInhabitedCompSource</span>.<span class=\"name\">default</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.instInhabitedCompSource.default","kind":"def","line":84,"name":"Mathlib.Tactic.Linarith.instInhabitedCompSource.default","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L84-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.scale\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">scale</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.scale","kind":"ctor","line":83,"name":"Mathlib.Tactic.Linarith.CompSource.scale","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L83-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.add","kind":"ctor","line":82,"name":"Mathlib.Tactic.Linarith.CompSource.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L82-L82"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.assump\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span>.<span class=\"name\">assump</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\">CompSource</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource.assump","kind":"ctor","line":81,"name":"Mathlib.Tactic.Linarith.CompSource.assump","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L81-L81"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Linarith</span>.<span class=\"name\">CompSource</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"`CompSource` tracks the source of a comparison.\nThe atomic source of a comparison is an assumption, indexed by a natural number.\nTwo comparisons can be added to produce a new comparison,\nand one comparison can be scaled by a natural number to produce a new comparison.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Mathlib.Tactic.Linarith.CompSource","kind":"inductive","line":74,"name":"Mathlib.Tactic.Linarith.CompSource","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L74-L84"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instSDiff_mathlib\"><span class=\"name\">Std</span>.<span class=\"name\">TreeSet</span>.<span class=\"name\">instSDiff_mathlib</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#SDiff\">SDiff</a> <span class=\"fn\">(<a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.instSDiff_mathlib","kind":"instance","line":61,"name":"Std.TreeSet.instSDiff_mathlib","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L61-L61"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff\"><span class=\"name\">Std</span>.<span class=\"name\">TreeSet</span>.<span class=\"name\">sdiff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">cmp</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span> → <a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Std/Data/TreeSet/Basic.html#Std.TreeSet\">TreeSet</a> <span class=\"fn\">α</span> <span class=\"fn\">cmp</span></span></div></div>","info":{"doc":"`O(n₁ * (log n₁ + log n₂))`. Constructs the set of all elements of `t₁` that are not in `t₂`.\n","docLink":"./Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.html#Std.TreeSet.sdiff","kind":"def","line":56,"name":"Std.TreeSet.sdiff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Linarith/Oracle/FourierMotzkin.lean#L56-L59"}}],"imports":["Init","Batteries.Lean.HashMap","Mathlib.Tactic.Linarith.Datatypes"],"instances":[{"className":"SDiff","name":"Std.TreeSet.instSDiff_mathlib","typeNames":["Std.TreeSet"]},{"className":"Inhabited","name":"Mathlib.Tactic.Linarith.instInhabitedCompSource","typeNames":["Mathlib.Tactic.Linarith.CompSource"]},{"className":"Std.ToFormat","name":"Mathlib.Tactic.Linarith.instToFormatCompSource","typeNames":["Mathlib.Tactic.Linarith.CompSource"]},{"className":"Std.ToFormat","name":"Mathlib.Tactic.Linarith.instToFormatPComp","typeNames":["Mathlib.Tactic.Linarith.PComp"]},{"className":"ToString","name":"Mathlib.Tactic.Linarith.instToStringPComp","typeNames":["Mathlib.Tactic.Linarith.PComp"]}],"name":"Mathlib.Tactic.Linarith.Oracle.FourierMotzkin"}