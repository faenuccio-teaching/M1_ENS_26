{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«instance argument order»\"><span class=\"name\">LibraryNote</span>.<span class=\"name\">«instance argument order»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote\">Batteries.Util.LibraryNote</a></div></div>","info":{"doc":"When type class inference applies an instance, it attempts to solve the sub-goals from left to\nright (it used to be from right to left in lean 3). For example in\n```\ninstance {p : α → Sort*} [∀ x, IsEmpty (p x)] [Nonempty α] : IsEmpty (∀ x, p x)\n```\nwe make sure to write `[∀ x, IsEmpty (p x)]` on the left of `[Nonempty α]` to avoid an expensive\nsearch for `Nonempty α` when there is no instance for `∀ x, IsEmpty (p x)`.\n\nThis helps to speed up failing type class searches, for example those triggered by `simp` lemmas.\n\nIn some situations, we can't reorder type class assumptions because one depends on the other,\nfor example in\n```\ninstance {G : Type*} [Group G] [IsKleinFour G] : IsAddKleinFour (Additive G)\n```\nwhere the `Group G` instance appears in `IsKleinFour G`. Future work may be done to improve the\ntype class synthesis order in this situation.\n","docLink":"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«instance argument order»","kind":"def","line":236,"name":"LibraryNote.«instance argument order»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L236-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«lower instance priority»\"><span class=\"name\">LibraryNote</span>.<span class=\"name\">«lower instance priority»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote\">Batteries.Util.LibraryNote</a></div></div>","info":{"doc":"Certain instances always apply during type-class resolution. For example, the instance\n`AddCommGroup.toAddGroup {α} [AddCommGroup α] : AddGroup α` applies to all type-class\nresolution problems of the form `AddGroup _`, and type-class inference will then do an\nexhaustive search to find a commutative group. These instances take a long time to fail.\nOther instances will only apply if the goal has a certain shape. For example\n`Int.instAddGroupInt : AddGroup ℤ` or\n`Prod.instAddGroup {α β} [AddGroup α] [AddGroup β] : AddGroup (α × β)`. Usually these instances\nwill fail quickly, and when they apply, they are almost always the desired instance.\nFor this reason, we want the instances of the second type (that only apply in specific cases) to\nalways have higher priority than the instances of the first type (that always apply).\nSee also [mathlib#1561](https://github.com/leanprover-community/mathlib/issues/1561).\n\nTherefore, if we create an instance that always applies, we set the priority of these instances to\n100 (or something similar, which is below the default value of 1000).\n","docLink":"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«lower instance priority»","kind":"def","line":219,"name":"LibraryNote.«lower instance priority»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L219-L234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«implicit instance arguments»\"><span class=\"name\">LibraryNote</span>.<span class=\"name\">«implicit instance arguments»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote\">Batteries.Util.LibraryNote</a></div></div>","info":{"doc":"There are places where typeclass arguments are specified with implicit `{}` brackets instead of\nthe usual `[]` brackets. This is done when the instances can be inferred because they are implicit\narguments to the type of one of the other arguments. When they can be inferred from these other\narguments, it is faster to use this method than to use type class inference.\n\nFor example, when writing lemmas about `(f : α →+* β)`, it is faster to specify the fact that `α`\nand `β` are `Semiring`s as `{rα : Semiring α} {rβ : Semiring β}` rather than the usual\n`[Semiring α] [Semiring β]`.\n","docLink":"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«implicit instance arguments»","kind":"def","line":208,"name":"LibraryNote.«implicit instance arguments»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L208-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«reducible non-instances»\"><span class=\"name\">LibraryNote</span>.<span class=\"name\">«reducible non-instances»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote\">Batteries.Util.LibraryNote</a></div></div>","info":{"doc":"Some definitions that define objects of a class cannot be instances, because they have an\nexplicit argument that does not occur in the conclusion. An example is `Preorder.lift` that has a\nfunction `f : α → β` as an explicit argument to lift a preorder on `β` to a preorder on `α`.\n\nIf these definitions are used to define instances of this class *and* this class is an argument to\nsome other type-class so that type-class inference will have to unfold these instances to check\nfor definitional equality, then these definitions should be marked `@[reducible]`.\n\nFor example, `Preorder.lift` is used to define `Units.Preorder` and `PartialOrder.lift` is used\nto define `Units.PartialOrder`. In some cases it is important that type-class inference can\nrecognize that `Units.Preorder` and `Units.PartialOrder` give rise to the same `LE` instance.\nFor example, you might have another class that takes `[LE α]` as an argument, and this argument\nsometimes comes from `Units.Preorder` and sometimes from `Units.PartialOrder`.\nTherefore, `Preorder.lift` and `PartialOrder.lift` are marked `@[reducible]`.\n","docLink":"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«reducible non-instances»","kind":"def","line":191,"name":"LibraryNote.«reducible non-instances»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L191-L206"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«the algebraic hierarchy»\"><span class=\"name\">LibraryNote</span>.<span class=\"name\">«the algebraic hierarchy»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote\">Batteries.Util.LibraryNote</a></div></div>","info":{"doc":"# The algebraic hierarchy\n\nIn any theorem proving environment,\nthere are difficult decisions surrounding the design of the \"algebraic hierarchy\".\n\nThere is a danger of exponential explosion in the number of gadgets,\nespecially once interactions between algebraic and order/topological/etc. structures are considered.\n\nIn mathlib, we try to avoid this by only introducing new algebraic typeclasses either\n1. when there is \"real mathematics\" to be done with them, or\n2. when there is a meaningful gain in simplicity by factoring out a common substructure.\n\n(As examples, at this point we don't have `Loop`, or `UnitalMagma`,\nbut we do have `LieSubmodule` and `TopologicalField`!\nWe also have `GroupWithZero`, as an exemplar of point 2.)\n\nGenerally in mathlib we use the extension mechanism (so `CommRing` extends `Ring`)\nrather than mixins (e.g. with separate `Ring` and `CommMul` classes),\nin part because of the potential blow-up in term sizes described at\nhttps://www.ralfj.de/blog/2019/05/15/typeclasses-exponential-blowup.html\nHowever there is tension here, as it results in considerable duplication in the API,\nparticularly in the interaction with order structures.\n\nThis library note is not intended as a design document\njustifying and explaining the history of mathlib's algebraic hierarchy!\nInstead it is intended as a developer's guide, for contributors wanting to extend\n(either new leaves, or new intermediate classes) the algebraic hierarchy as it exists.\n\n(Ideally we would have both a tour guide to the existing hierarchy,\nand an account of the design choices.\nSee https://arxiv.org/abs/1910.09336 for an overview of mathlib as a whole,\nwith some attention to the algebraic hierarchy and\nhttps://leanprover-community.github.io/mathlib-overview.html\nfor a summary of what is in mathlib today.)\n\n## Instances\n\nWhen adding a new typeclass `Z` to the algebraic hierarchy\none should attempt to add the following constructions and results,\nwhen applicable:\n\n* Instances transferred elementwise to products, like `Prod.Monoid`.\n  See `Mathlib/Algebra/Group/Prod.lean` for more examples.\n  ```\n  instance Prod.Z [Z M] [Z N] : Z (M × N) := ...\n  ```\n* Instances transferred elementwise to pi types, like `Pi.Monoid`.\n  See `Mathlib/Algebra/Group/Pi.lean` for more examples.\n  ```\n  instance Pi.Z [∀ i, Z <| f i] : Z (Π i : I, f i) := ...\n  ```\n* Instances transferred to `MulOpposite M`, like `MulOpposite.Monoid`.\n  See `Mathlib/Algebra/Opposites.lean` for more examples.\n  ```\n  instance MulOpposite.Z [Z M] : Z (MulOpposite M) := ...\n  ```\n* Instances transferred to `ULift M`, like `ULift.Monoid`.\n  See `Mathlib/Algebra/Group/ULift.lean` for more examples.\n  ```\n  instance ULift.Z [Z M] : Z (ULift M) := ...\n  ```\n* Definitions for transferring the proof fields of instances along\n  injective or surjective functions that agree on the data fields,\n  like `Function.Injective.monoid` and `Function.Surjective.monoid`.\n  We make these definitions `abbrev`, see note [reducible non-instances].\n  See `Mathlib/Algebra/Group/InjSurj.lean` for more examples.\n  ```\n  abbrev Function.Injective.Z [Z M₂] (f : M₁ → M₂) (hf : f.Injective)\n    (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) : Z M₁ := ...\n\n  abbrev Function.Surjective.Z [Z M₁] (f : M₁ → M₂) (hf : f.Surjective)\n    (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) : Z M₂ := ...\n  ```\n* Instances transferred elementwise to `Finsupp`s, like `Finsupp.semigroup`.\n  See `Mathlib/Data/Finsupp/Pointwise.lean` for more examples.\n  ```\n  instance Finsupp.Z [Z β] : Z (α →₀ β) := ...\n  ```\n* Instances transferred elementwise to `Set`s, like `Set.monoid`.\n  See `Mathlib/Algebra/Pointwise.lean` for more examples.\n  ```\n  instance Set.Z [Z α] : Z (Set α) := ...\n  ```\n* Definitions for transferring the entire structure across an equivalence, like `Equiv.monoid`.\n  See `Mathlib/Data/Equiv/TransferInstance.lean` for more examples. See also the `transport` tactic.\n  ```\n  def Equiv.Z (e : α ≃ β) [Z β] : Z α := ...\n  /-- When there is a new notion of `Z`-equiv: -/\n  def Equiv.ZEquiv (e : α ≃ β) [Z β] : by { letI := Equiv.Z e, exact α ≃Z β } := ...\n  ```\n\n## Subobjects\n\nWhen a new typeclass `Z` adds new data fields,\nyou should also create a new `SubZ` `structure` with a `carrier` field.\n\nThis can be a lot of work; for now try to closely follow the existing examples\n(e.g. `Submonoid`, `Subring`, `Subalgebra`).\nWe would very much like to provide some automation here, but a prerequisite will be making\nall the existing APIs more uniform.\n\nIf `Z` extends `Y`, then `SubZ` should usually extend `SubY`.\n\nWhen `Z` adds only new proof fields to an existing structure `Y`,\nyou should provide instances transferring\n`Z α` to `Z (SubY α)`, like `Submonoid.toCommMonoid`.\nTypically this is done using the `Function.Injective.Z` definition mentioned above.\n```\ninstance SubY.toZ [Z α] : Z (SubY α) :=\n  coe_injective.Z coe ...\n```\n\n## Morphisms and equivalences\n\n## Category theory\n\nFor many algebraic structures, particularly ones used in representation theory, algebraic geometry,\netc., we also define \"bundled\" versions, which carry `category` instances.\n\nThese bundled versions are usually named by appending `Cat`,\nso for example we have `AddCommGrpCat` as a bundled `AddCommGroup`, and `TopCommRingCat`\n(which bundles together `CommRing`, `TopologicalSpace`, and `IsTopologicalRing`).\n\nThese bundled versions have many appealing features:\n* a uniform notation for morphisms `X ⟶ Y`\n* a uniform notation (and definition) for isomorphisms `X ≅ Y`\n* a uniform API for subobjects, via the partial order `Subobject X`\n* interoperability with unbundled structures, via coercions to `Type`\n  (so if `G : AddCommGrpCat`, you can treat `G` as a type,\n  and it automatically has an `AddCommGroup` instance)\n  and lifting maps `AddCommGrpCat.of G`, when `G` is a type with an `AddCommGroup` instance.\n\nIf, for example you do the work of proving that a typeclass `Z` has a good notion of tensor product,\nyou are strongly encouraged to provide the corresponding `MonoidalCategory` instance\non a bundled version.\nThis ensures that the API for tensor products is complete, and enables use of general machinery.\nSimilarly if you prove universal properties, or adjunctions, you are encouraged to state these\nusing categorical language!\n\nOne disadvantage of the bundled approach is that we can only speak of morphisms between\nobjects living in the same type-theoretic universe.\nIn practice this is rarely a problem.\n\n# Making a pull request\n\nWith so many moving parts, how do you actually go about changing the algebraic hierarchy?\n\nWe're still evolving how to handle this, but the current suggestion is:\n\n* If you're adding a new \"leaf\" class, the requirements are lower,\n  and an initial PR can just add whatever is immediately needed.\n* A new \"intermediate\" class, especially low down in the hierarchy,\n  needs to be careful about leaving gaps.\n\nIn a perfect world, there would be a group of simultaneous PRs that basically cover everything!\n(Or at least an expectation that PRs may not be merged immediately while waiting on other\nPRs that fill out the API.)\n\nHowever \"perfect is the enemy of good\", and it would also be completely reasonable\nto add a TODO list in the main module doc-string for the new class,\nbriefly listing the parts of the API which still need to be provided.\nHopefully this document makes it easy to assemble this list.\n\nAnother alternative to a TODO list in the doc-strings is adding Github issues.\n","docLink":"./Mathlib/Algebra/HierarchyDesign.html#LibraryNote.«the algebraic hierarchy»","kind":"def","line":25,"name":"LibraryNote.«the algebraic hierarchy»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Algebra/HierarchyDesign.lean#L25-L189"}}],"imports":["Init","Mathlib.Init","Mathlib.Tactic.Basic"],"instances":[],"name":"Mathlib.Algebra.HierarchyDesign"}