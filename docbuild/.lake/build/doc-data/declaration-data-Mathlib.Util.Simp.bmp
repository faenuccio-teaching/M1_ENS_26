{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Util/Simp.html#Lean.Meta.Simp.Methods.dischargeQ?\"><span class=\"name\">Lean</span>.<span class=\"name\">Meta</span>.<span class=\"name\">Simp</span>.<span class=\"name\">Methods</span>.<span class=\"name\">dischargeQ?</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">M</span> : <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Methods\">Methods</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.SimpM\">SimpM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">Q(<span class=\"fn\">«$a»</span>)</span>)</span></span></div></div>","info":{"doc":"`Qq` version of `Lean.Meta.Simp.Methods.discharge?`, which avoids having to use `~q` matching\non the proof expression returned by `discharge?`\n\n`dischargeQ? (a : Q(Prop))` attempts to prove `a` using the discharger, returning\n`some (pf : Q(a))` if a proof is found and `none` otherwise. ","docLink":"./Mathlib/Util/Simp.html#Lean.Meta.Simp.Methods.dischargeQ?","kind":"def","line":24,"name":"Lean.Meta.Simp.Methods.dischargeQ?","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Util/Simp.lean#L24-L30"}}],"imports":["Init","Lean.Meta.Tactic.Simp.Types","Mathlib.Init","Qq"],"instances":[],"name":"Mathlib.Util.Simp"}