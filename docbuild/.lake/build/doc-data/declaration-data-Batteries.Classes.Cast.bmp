{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Batteries/Classes/Cast.html#LibraryNote.«coercion into rings»\"><span class=\"name\">LibraryNote</span>.<span class=\"name\">«coercion into rings»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Batteries/Util/LibraryNote.html#Batteries.Util.LibraryNote\">Batteries.Util.LibraryNote</a></div></div>","info":{"doc":"Coercions such as `Nat.castCoe` that go from a concrete structure such as\n`Nat` to an arbitrary ring `R` should be set up as follows:\n```lean\ninstance : CoeTail Nat R where coe := ...\ninstance : CoeHTCT Nat R where coe := ...\n```\n\nIt needs to be `CoeTail` instead of `Coe` because otherwise type-class\ninference would loop when constructing the transitive coercion `Nat → Nat → Nat → ...`.\nSometimes we also need to declare the `CoeHTCT` instance\nif we need to shadow another coercion\n(e.g. `Nat.cast` should be used over `Int.ofNat`).\n","docLink":"./Batteries/Classes/Cast.html#LibraryNote.«coercion into rings»","kind":"def","line":12,"name":"LibraryNote.«coercion into rings»","sourceLink":"https://github.com/leanprover-community/batteries/blob/6254bed25866358ce4f841fa5a13b77de04ffbc8/Batteries/Classes/Cast.lean#L12-L26"}}],"imports":["Init","Batteries.Util.LibraryNote"],"instances":[],"name":"Batteries.Classes.Cast"}