{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.«command#find_syntax_Approx»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">FindSyntax</span>.<span class=\"name\">«command#find_syntax_Approx»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `#find_syntax` command takes as input a string `str` and retrieves from the environment\nall the candidates for `syntax` terms that contain the string `str`.\n\nIt also makes a very crude effort at regenerating what the syntax looks like:\nthis is supposed to be just indicative of what the syntax may look like, but there is no\nguarantee or expectation of correctness.\n\nThe optional trailing `approx`, as in `#find_syntax \"∘\" approx`, is only intended to make tests\nmore stable: rather than outputting the exact count of the overall number of existing syntax\ndeclarations, it returns its round-down to the previous multiple of 100.\n","docLink":"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.«command#find_syntax_Approx»","kind":"def","line":58,"name":"Mathlib.FindSyntax.«command#find_syntax_Approx»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/FindSyntax.lean#L58-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.litToString\"><span class=\"name\">Mathlib</span>.<span class=\"name\">FindSyntax</span>.<span class=\"name\">litToString</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <a href=\"./Init/Prelude.html#String\">String</a></span></div></div>","info":{"doc":"`litToString expr` converts the input `Expr`ession `expr` into the \"natural\" string that\nit corresponds to, in case `expr` is a `String`/`Nat`-literal, returning the empty string `\"\"`\notherwise.\n","docLink":"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.litToString","kind":"def","line":48,"name":"Mathlib.FindSyntax.litToString","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/FindSyntax.lean#L48-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.extractSymbols\"><span class=\"name\">Mathlib</span>.<span class=\"name\">FindSyntax</span>.<span class=\"name\">extractSymbols</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></span></div></div>","info":{"doc":"`extractSymbols expr` takes as input an `Expr`ession `expr`, assuming that it is the `value`\nof a \"parser\".\nIt returns the array of all subterms of `expr` that are the `Expr.lit` argument to\n`Lean.ParserDescr.symbol` and `Lean.ParserDescr.nonReservedSymbol` applications.\n\nThe output array serves as a way of regenerating what the syntax tree of the input parser is.\n","docLink":"./Mathlib/Tactic/FindSyntax.html#Mathlib.FindSyntax.extractSymbols","kind":"def","line":27,"name":"Mathlib.FindSyntax.extractSymbols","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/FindSyntax.lean#L27-L46"}}],"imports":["Init","Lean.Elab.Command","Mathlib.Init"],"instances":[],"name":"Mathlib.Tactic.FindSyntax"}