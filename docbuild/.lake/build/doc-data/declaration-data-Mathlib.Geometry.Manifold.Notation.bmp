{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termHasMFDerivAt%______Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termHasMFDerivAt%______Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`HasMFDerivAt% f x f'` elaborates to `HasMFDerivAt I J f x f'`,\ntrying to determine `I` and `J` from the local context. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termHasMFDerivAt%______Â»","kind":"def","line":569,"name":"Manifold.Â«termHasMFDerivAt%______Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L569-L577"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termHasMFDerivAt[_]______Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termHasMFDerivAt[_]______Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`HasMFDerivAt[s] f x f'` elaborates to `HasMFDerivWithinAt I J f s x f'`,\ntrying to determine `I` and `J` from the local context. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termHasMFDerivAt[_]______Â»","kind":"def","line":558,"name":"Manifold.Â«termHasMFDerivAt[_]______Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L558-L567"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMfderiv%__Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termMfderiv%__Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`mfderiv% f x` elaborates to `mfderiv I J f x`,\ntrying to determine `I` and `J` from the local context. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMfderiv%__Â»","kind":"def","line":551,"name":"Manifold.Â«termMfderiv%__Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L551-L556"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMfderiv[_]__Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termMfderiv[_]__Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`mfderiv[u] f x` elaborates to `mfderivWithin I J f u x`,\ntrying to determine `I` and `J` from the local context. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMfderiv[_]__Â»","kind":"def","line":543,"name":"Manifold.Â«termMfderiv[_]__Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L543-L549"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termCMDiff____\"><span class=\"name\">Manifold</span>.<span class=\"name\">termCMDiff____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`CMDiff n f` elaborates to `ContMDiff I J n f`,\ntrying to determine `I` and `J` from the local context.\n`n` is coerced to `WithTop â„•âˆ` if necessary (so passing a `â„•`, `âˆ` or `Ï‰` are all supported). ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termCMDiff____","kind":"def","line":534,"name":"Manifold.termCMDiff____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L534-L541"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termCMDiff[_]____Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termCMDiff[_]____Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`CMDiff[s] n f` elaborates to `ContMDiffOn I J n f s`,\ntrying to determine `I` and `J` from the local context.\n`n` is coerced to `WithTop â„•âˆ` if necessary (so passing a `â„•`, `âˆ` or `Ï‰` are all supported). ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termCMDiff[_]____Â»","kind":"def","line":524,"name":"Manifold.Â«termCMDiff[_]____Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L524-L532"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termCMDiffAt____\"><span class=\"name\">Manifold</span>.<span class=\"name\">termCMDiffAt____</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`CMDiffAt n f x` elaborates to `ContMDiffAt I J n f x`\ntrying to determine `I` and `J` from the local context.\n`n` is coerced to `WithTop â„•âˆ` if necessary (so passing a `â„•`, `âˆ` or `Ï‰` are all supported).\nThe argument `x` can be omitted. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termCMDiffAt____","kind":"def","line":514,"name":"Manifold.termCMDiffAt____","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L514-L522"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termCMDiffAt[_]____Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termCMDiffAt[_]____Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`CMDiffAt[s] n f x` elaborates to `ContMDiffWithinAt I J n f s x`,\ntrying to determine `I` and `J` from the local context.\n`n` is coerced to `WithTop â„•âˆ` if necessary (so passing a `â„•`, `âˆ` or `Ï‰` are all supported).\nThe argument `x` can be omitted. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termCMDiffAt[_]____Â»","kind":"def","line":503,"name":"Manifold.Â«termCMDiffAt[_]____Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L503-L512"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termMDiff__\"><span class=\"name\">Manifold</span>.<span class=\"name\">termMDiff__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`MDiff f` elaborates to `MDifferentiable I J f`,\ntrying to determine `I` and `J` from the local context. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termMDiff__","kind":"def","line":491,"name":"Manifold.termMDiff__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L491-L496"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMDiff[_]__Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termMDiff[_]__Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`MDiff[s] f` elaborates to `MDifferentiableOn I J f s`,\ntrying to determine `I` and `J` from the local context. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMDiff[_]__Â»","kind":"def","line":483,"name":"Manifold.Â«termMDiff[_]__Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L483-L489"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termMDiffAt__\"><span class=\"name\">Manifold</span>.<span class=\"name\">termMDiffAt__</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`MDiffAt f x` elaborates to `MDifferentiableAt I J f x`,\ntrying to determine `I` and `J` from the local context.\nThe argument `x` can be omitted. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.termMDiffAt__","kind":"def","line":456,"name":"Manifold.termMDiffAt__","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L456-L462"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMDiffAt[_]__Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termMDiffAt[_]__Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`MDiffAt[s] f x` elaborates to `MDifferentiableWithinAt I J f s x`,\ntrying to determine `I` and `J` from the local context.\nThe argument `x` can be omitted. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termMDiffAt[_]__Â»","kind":"def","line":447,"name":"Manifold.Â«termMDiffAt[_]__Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L447-L454"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModels\"><span class=\"name\">Manifold</span>.<span class=\"name\">Elab</span>.<span class=\"name\">findModels</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">es</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">Ã—</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"If the type of `e` is a non-dependent function between spaces `src` and `tgt`, try to find a\nmodel with corners on both `src` and `tgt`. If successful, return both models.\n\nWe pass `e` instead of just its type for better diagnostics.\n\nIf `es` is `some`, we verify that `src` and the type of `es` are definitionally equal. ","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModels","kind":"def","line":416,"name":"Manifold.Elab.findModels","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L416-L441"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModel\"><span class=\"name\">Manifold</span>.<span class=\"name\">Elab</span>.<span class=\"name\">findModel</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">baseInfo</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">Ã—</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Try to find a `ModelWithCorners` instance on a type (represented by an expression `e`),\nusing the local context to infer the appropriate instance. This supports the following cases:\n- the model with corners on the total space of a vector bundle\n- the model with corners on the tangent space of a manifold\n- a model with corners on a manifold, or on its underlying model space\n- a closed interval of real numbers\n- the complex upper half plane\n- a space of continuous k-linear maps\n- the trivial model `ğ“˜(ğ•œ, E)` on a normed space\n- if the above are not found, try to find a `NontriviallyNormedField` instance on the type of `e`,\n  and if successful, return `ğ“˜(ğ•œ)`.\n\nFurther cases can be added as necessary.\n\nReturn an expression describing the found model with corners.\n\n`baseInfo` is only used for the first case, a model with corners on the total space of the vector\nbundle. In this case, it contains a pair of expressions `(e, i)` describing the type of the base\nand the model with corners on the base: these are required to construct the right model with\ncorners.\n\nNote that the matching on `e` does not see through reducibility (e.g. we distinguish the `abbrev`\n`TangentBundle` from its definition), so `whnfR` should not be run on `e` prior to calling\n`findModel` on it.\n\nThis implementation is not maximally robust yet.\n","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.findModel","kind":"def","line":239,"name":"Manifold.Elab.findModel","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L239-L414"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termT%_Â»\"><span class=\"name\">Manifold</span>.<span class=\"name\">Â«termT%_Â»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Elaborator for sections in a fibre bundle: converts a section `s : Î  x : M, V x` as a dependent\nfunction to a non-dependent function into the total space. This handles the cases of\n- sections of a trivial bundle\n- vector fields on a manifold (i.e., sections of the tangent bundle)\n- sections of an explicit fibre bundle\n- turning a bare function `E â†’ E'` into a section of the trivial bundle `Bundle.Trivial E E'`\n\nThis elaborator searches the local context for suitable hypotheses for the above cases by matching\non the expression structure, avoiding `isDefEq`. Therefore, it should be fast enough to always run.\nThe search can be traced with `set_option Elab.DiffGeo.TotalSpaceMk true`.\n","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Â«termT%_Â»","kind":"def","line":191,"name":"Manifold.Â«termT%_Â»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L191-L204"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.totalSpaceMk\"><span class=\"name\">Manifold</span>.<span class=\"name\">Elab</span>.<span class=\"name\">totalSpaceMk</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Utility for sections in a fibre bundle: if an expression `e` is a section\n`s : Î  x : M, V x` as a dependent function, convert it to a non-dependent function into the total\nspace. This handles the cases of\n- sections of a trivial bundle\n- vector fields on a manifold (i.e., sections of the tangent bundle)\n- sections of an explicit fibre bundle\n- turning a bare function `E â†’ E'` into a section of the trivial bundle `Bundle.Trivial E E'`\n\nThis searches the local context for suitable hypotheses for the above cases by matching\non the expression structure, avoiding `isDefEq`. Therefore, it should be fast enough to always run.\nThis process can be traced with `set_option Elab.DiffGeo.TotalSpaceMk true`.\n\nAll applications of `e` in the resulting expression are beta-reduced.\nIf none of the handled cases apply, we simply return `e` (after beta-reducing).\n\nThis function is used for implementing the `T%` elaborator.\n","docLink":"./Mathlib/Geometry/Manifold/Notation.html#Manifold.Elab.totalSpaceMk","kind":"def","line":122,"name":"Manifold.Elab.totalSpaceMk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Geometry/Manifold/Notation.lean#L122-L186"}}],"imports":["Init","Mathlib.Geometry.Manifold.ContMDiff.Defs","Mathlib.Geometry.Manifold.MFDeriv.Defs"],"instances":[],"name":"Mathlib.Geometry.Manifold.Notation"}