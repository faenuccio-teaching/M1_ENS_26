{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.«termProd_assoc%»\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">«termProd_assoc%»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"`prod_assoc%` elaborates to the \"obvious\" equivalence between iterated products of types,\nregardless of how the products are parenthesized.\nThe `prod_assoc%` term uses the expected type when elaborating.\nFor example, `(prod_assoc% : (α × β) × (γ × δ) ≃ α × (β × γ) × δ)`.\n\nThe elaborator can handle holes in the expected type,\nso long as they eventually get filled by unification.\n```lean\nexample : (α × β) × (γ × δ) ≃ α × (β × γ) × δ :=\n  (prod_assoc% : _ ≃ α × β × γ × δ).trans prod_assoc%\n```\n","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.«termProd_assoc%»","kind":"def","line":153,"name":"Lean.Expr.«termProd_assoc%»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L153-L153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.elabProdAssoc\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">elabProdAssoc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElab\">Elab.Term.TermElab</a></div></div>","info":{"doc":"Elaborator for `prod_assoc%`. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.elabProdAssoc","kind":"def","line":128,"name":"Lean.Expr.elabProdAssoc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L128-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.prodAssocStx\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">prodAssocStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">ParserDescr</a></div></div>","info":{"doc":"IMPLEMENTATION: Syntax used in the implementation of `prod_assoc%`.\nThis elaborator postpones if there are metavariables in the expected type,\nand to propagate the fact that this elaborator produces an `Equiv`,\nthe `prod_assoc%` macro sets things up with a type ascription.\nThis enables using `prod_assoc%` with, for example `Equiv.trans` dot notation. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.prodAssocStx","kind":"def","line":120,"name":"Lean.Expr.prodAssocStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L120-L125"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdEquiv\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">mkProdEquiv</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Construct the equivalence between iterated products of the same type, associated\nin possibly different ways. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdEquiv","kind":"def","line":110,"name":"Lean.Expr.mkProdEquiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L110-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdFun\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">mkProdFun</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Given two expressions corresponding to iterated products of the same types, associated in\npossibly different ways, this constructs the \"obvious\" function from one to the other. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdFun","kind":"def","line":97,"name":"Lean.Expr.mkProdFun","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L97-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.convertTo\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">convertTo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P1 </span><span class=\"fn\">P2</span> : <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"Converts a term `e` in an iterated product `P1` into a term of an iterated product `P2`.\nHere `e` is an `Expr` representing the term, and the iterated products are represented\nby terms of `ProdTree`. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.convertTo","kind":"def","line":91,"name":"Lean.Expr.ProdTree.convertTo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L91-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.pack\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">pack</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span></div></div>","info":{"doc":"This function should act as the \"reverse\" of `ProdTree.unpack`, constructing\na term of the iterated product out of a list of terms of the types appearing in the product. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.pack","kind":"def","line":74,"name":"Lean.Expr.ProdTree.pack","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L74-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.unpack\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">unpack</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span></span></div></div>","info":{"doc":"Given `P : ProdTree` representing an iterated product and `e : Expr` which\nshould correspond to a term of the iterated product, this will return\na list, whose items correspond to the leaves of `P` (i.e. the types appearing in the product),\nwhere each item is the appropriate composition of `Prod.fst` and `Prod.snd` applied to `e`\nresulting in an element of the type corresponding to the leaf.\n\nFor example, if `P` corresponds to `(X × Y) × Z` and `t : (X × Y) × Z`, then this\nshould return `[t.fst.fst, t.fst.snd, t.snd]`.\n","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.unpack","kind":"def","line":58,"name":"Lean.Expr.ProdTree.unpack","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L58-L72"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdTree\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">mkProdTree</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">MetaM</a> <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a></span></div></div>","info":{"doc":"Make a `ProdTree` out of an `Expr`. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.mkProdTree","kind":"opaque","line":49,"name":"Lean.Expr.mkProdTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L49-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.components\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">components</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></span></div></div>","info":{"doc":"The components of an iterated product, presented as a `ProdTree`. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.components","kind":"def","line":44,"name":"Lean.Expr.ProdTree.components","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L44-L47"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.size\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">size</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"The number of types appearing in an iterated product encoded as a `ProdTree`. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.size","kind":"def","line":39,"name":"Lean.Expr.ProdTree.size","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L39-L42"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.getType\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">getType</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></span></div></div>","info":{"doc":"The iterated product corresponding to a `ProdTree`. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.getType","kind":"def","line":34,"name":"Lean.Expr.ProdTree.getType","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L34-L37"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.instReprProdTree.repr\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instReprProdTree</span>.<span class=\"name\">repr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Format</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.instReprProdTree.repr","kind":"def","line":32,"name":"Lean.Expr.instReprProdTree.repr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.instReprProdTree\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">instReprProdTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.instReprProdTree","kind":"instance","line":32,"name":"Lean.Expr.instReprProdTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L32-L32"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.prod\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">prod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fst </span><span class=\"fn\">snd</span> : <a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lfst </span><span class=\"fn\">lsnd</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.prod","kind":"ctor","line":31,"name":"Lean.Expr.ProdTree.prod","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L31-L31"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.type\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span>.<span class=\"name\">type</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tp</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <a href=\"./Lean/Level.html#Lean.Level\">Level</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\">ProdTree</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree.type","kind":"ctor","line":30,"name":"Lean.Expr.ProdTree.type","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L30-L30"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">ProdTree</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A helper type to keep track of universe levels and types in iterated products. ","docLink":"./Mathlib/Tactic/ProdAssoc.html#Lean.Expr.ProdTree","kind":"inductive","line":28,"name":"Lean.Expr.ProdTree","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ProdAssoc.lean#L28-L32"}}],"imports":["Init","Mathlib.Lean.Expr.Basic","Mathlib.Logic.Equiv.Defs"],"instances":[{"className":"Repr","name":"Lean.Expr.instReprProdTree","typeNames":["Lean.Expr.ProdTree"]}],"name":"Mathlib.Tactic.ProdAssoc"}