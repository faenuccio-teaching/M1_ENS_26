{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">type </span><span class=\"fn\">proof</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add `proof : type` to the congruence closure. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.add","kind":"def","line":1424,"name":"Mathlib.Tactic.CC.CCM.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1424-L1467"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs </span><span class=\"fn\">H</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add `H : lhs = rhs` or `H : lhs ≍ rhs` to the congruence closure. Don't forget to internalize\n`lhs` and `rhs` beforehand. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvCore","kind":"def","line":1418,"name":"Mathlib.Tactic.CC.CCM.addEqvCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1418-L1422"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalize\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalize</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Internalize `e` so that the congruence closure can deal with the given expression. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalize","kind":"def","line":1413,"name":"Mathlib.Tactic.CC.CCM.internalize","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1413-L1416"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Process the tasks in the `todo` field. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processTodo","kind":"def","line":1402,"name":"Mathlib.Tactic.CC.CCM.processTodo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1402-L1411"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addEqvStep</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Performs one step in the process when the new equation is added.\n\nHere, `H` contains the proof that `e₁ = e₂` (if `heqProof` is false)\nor `e₁ ≍ e₂` (if `heqProof` is true). ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addEqvStep","kind":"def","line":1239,"name":"Mathlib.Tactic.CC.CCM.addEqvStep","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1239-L1400"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `e` to subexpressions of `e`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateDown","kind":"def","line":1226,"name":"Mathlib.Tactic.CC.CCM.propagateDown","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1226-L1237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateExistsDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateExistsDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `¬∃ x, p x` to `∀ x, ¬p x`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateExistsDown","kind":"def","line":1218,"name":"Mathlib.Tactic.CC.CCM.propagateExistsDown","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1218-L1224"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateEqDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `(a = b) = True` to `a = b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqDown","kind":"def","line":1212,"name":"Mathlib.Tactic.CC.CCM.propagateEqDown","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1212-L1216"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateNotDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `¬a` to `a`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotDown","kind":"def","line":1201,"name":"Mathlib.Tactic.CC.CCM.propagateNotDown","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1201-L1210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateOrDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a ∨ b = False` to `a = False` and `b = False`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrDown","kind":"def","line":1193,"name":"Mathlib.Tactic.CC.CCM.propagateOrDown","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1193-L1199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndDown\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateAndDown</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a ∧ b = True` to `a = True` and `b = True`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndDown","kind":"def","line":1185,"name":"Mathlib.Tactic.CC.CCM.propagateAndDown","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1185-L1191"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateValueInconsistency\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateValueInconsistency</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Derive contradiction if we can get equality between different values. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateValueInconsistency","kind":"def","line":1173,"name":"Mathlib.Tactic.CC.CCM.propagateValueInconsistency","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1173-L1183"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateConstructorEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given a new equality `e₁ = e₂`, where `e₁` and `e₂` are constructor applications.\nImplement the following implications:\n```lean\nc a₁ ... aₙ = c b₁ ... bₙ => a₁ = b₁, ..., aₙ = bₙ\n\nc₁ ... = c₂ ... => False\n```\nwhere `c`, `c₁` and `c₂` are constructors ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateConstructorEq","kind":"def","line":1125,"name":"Mathlib.Tactic.CC.CCM.propagateConstructorEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1125-L1171"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateProjectionConstructor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateProjectionConstructor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">c</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given `c` a constructor application, if `p` is a projection application (not `.proj _ _ _`, but\n`.app (.const projName _) _`) such that major premise is\nequal to `c`, then propagate new equality.\n\nExample: if `p` is of the form `b.fst`, `c` is of the form `(x, y)`, and `b = c`, we add the\nequality `(x, y).fst = x` ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateProjectionConstructor","kind":"def","line":1101,"name":"Mathlib.Tactic.CC.CCM.propagateProjectionConstructor","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1101-L1123"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBetaToEqc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateBetaToEqc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fnRoots </span><span class=\"fn\">lambdas</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newLambdaApps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"For each `fnRoot` in `fnRoots` traverse its parents, and look for a parent prefix that is\nin the same equivalence class of the given lambdas.\n\nremark All expressions in lambdas are in the same equivalence class ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBetaToEqc","kind":"def","line":1075,"name":"Mathlib.Tactic.CC.CCM.propagateBetaToEqc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1075-L1099"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkInvariant\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkInvariant</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Check for integrity of the `CCStructure`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkInvariant","kind":"def","line":1071,"name":"Mathlib.Tactic.CC.CCM.checkInvariant","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1071-L1073"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.reinsertParents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">reinsertParents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Reinsert parents of `e` to the congruence table and the symm congruence table.\n\nTogether with `removeParents`, this allows modifying parents of an expression. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.reinsertParents","kind":"def","line":1058,"name":"Mathlib.Tactic.CC.CCM.reinsertParents","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1058-L1069"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collectFnRoots\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">collectFnRoots</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">root</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fnRoots</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Traverse the `root`'s equivalence class, and for each function application,\ncollect the function's equivalence class root. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collectFnRoots","kind":"def","line":1041,"name":"Mathlib.Tactic.CC.CCM.collectFnRoots","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1041-L1056"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.invertTrans\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">invertTrans</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newFlipped</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newTarget</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newProof</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a></span> := <a href=\"./Init/Prelude.html#Option.none\">none</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"The fields `target` and `proof` in `e`'s entry are encoding a transitivity proof\nLet `e.rootTarget` and `e.rootProof` denote these fields.\n```lean\ne = e.rootTarget            := e.rootProof\n_ = e.rootTarget.rootTarget := e.rootTarget.rootProof\n ...\n_ = e.root                  := ...\n```\nThe transitivity proof eventually reaches the root of the equivalence class.\nThis method \"inverts\" the proof. That is, the `target` goes from `e.root` to e after\nwe execute it.\n","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.invertTrans","kind":"opaque","line":1016,"name":"Mathlib.Tactic.CC.CCM.invertTrans","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L1016-L1039"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.removeParents\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">removeParents</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parentsToPropagate</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Remove parents of `e` from the congruence table and the symm congruence table, and append\nparents to propagate equality, to `parentsToPropagate`.\nReturns the new value of `parentsToPropagate`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.removeParents","kind":"def","line":980,"name":"Mathlib.Tactic.CC.CCM.removeParents","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L980-L1014"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mayPropagate\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mayPropagate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"Can we propagate equality from subexpressions of `e` to `e`? ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mayPropagate","kind":"def","line":975,"name":"Mathlib.Tactic.CC.CCM.mayPropagate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L975-L978"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkEntry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkEntry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">interpreted</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add a new entry for `e` to the congruence closure. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkEntry","kind":"opaque","line":966,"name":"Mathlib.Tactic.CC.CCM.mkEntry","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L966-L972"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processSubsingletonElem\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processSubsingletonElem</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"If `e` is a subsingleton element, push the equality proof between `e` and its canonical form\nto the todo list or register `e` as the canonical form of itself. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processSubsingletonElem","kind":"opaque","line":941,"name":"Mathlib.Tactic.CC.CCM.processSubsingletonElem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L941-L964"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.applySimpleEqvs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">applySimpleEqvs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"This method is invoked during internalization and eagerly apply basic equivalences for term `e`\nExamples:\n- If `e := cast H e'`, then it merges the equivalence classes of `cast H e'` and `e'`\n\nIn principle, we could mark theorems such as `cast_eq` as simplification rules, but this created\nproblems with the builtin support for cast-introduction in the ematching module in Lean 3.\nTODO: check if this is now possible in Lean 4.\n\nEagerly merging the equivalence classes is also more efficient. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.applySimpleEqvs","kind":"opaque","line":874,"name":"Mathlib.Tactic.CC.CCM.applySimpleEqvs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L874-L939"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from subexpressions of `e` to `e`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateUp","kind":"opaque","line":856,"name":"Mathlib.Tactic.CC.CCM.propagateUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L856-L872"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateEqUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a` and `b` to *disprove* `a = b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateEqUp","kind":"def","line":815,"name":"Mathlib.Tactic.CC.CCM.propagateEqUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L815-L854"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIteUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateIteUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `p`, `a` and `b` to `if p then a else b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIteUp","kind":"def","line":802,"name":"Mathlib.Tactic.CC.CCM.propagateIteUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L802-L813"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateImpUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateImpUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a` and `b` to `a → b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateImpUp","kind":"opaque","line":767,"name":"Mathlib.Tactic.CC.CCM.propagateImpUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L767-L800"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateNotUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a` to `¬a`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateNotUp","kind":"def","line":753,"name":"Mathlib.Tactic.CC.CCM.propagateNotUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L753-L765"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateOrUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a` and `b` to `a ∨ b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateOrUp","kind":"def","line":731,"name":"Mathlib.Tactic.CC.CCM.propagateOrUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L731-L750"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateAndUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a` and `b` to `a ∧ b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateAndUp","kind":"def","line":709,"name":"Mathlib.Tactic.CC.CCM.propagateAndUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L709-L728"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIffUp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateIffUp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Propagate equality from `a` and `b` to `a ↔ b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateIffUp","kind":"def","line":696,"name":"Mathlib.Tactic.CC.CCM.propagateIffUp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L696-L707"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Internalize `e` so that the congruence closure can deal with the given expression. Don't forget\nto process the tasks in the `todo` field later. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeCore","kind":"opaque","line":650,"name":"Mathlib.Tactic.CC.CCM.internalizeCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L650-L694"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAppLit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeAppLit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"The specialized `internalizeCore` for applications or literals. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAppLit","kind":"opaque","line":585,"name":"Mathlib.Tactic.CC.CCM.internalizeAppLit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L585-L648"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent?</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Internalize `e` so that the AC module can deal with the given expression.\n\nIf the expression does not contain an AC operator, or the parent expression\nis already processed by `internalizeAC`, this operation does nothing. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeAC","kind":"def","line":558,"name":"Mathlib.Tactic.CC.CCM.internalizeAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L558-L582"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.convertAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">convertAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">op </span><span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">args</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> (<span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></div></div>","info":{"doc":"Given `e := op₁ (op₂ a₁ a₂) (op₃ a₃ a₄)` where `opₙ`s are canonicalized to `op`, internalize\n`aₙ`s as AC variables and return `(op (op a₁ a₂) (op a₃ a₄), args ++ #[a₁, a₂, a₃, a₄])`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.convertAC","kind":"opaque","line":546,"name":"Mathlib.Tactic.CC.CCM.convertAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L546-L556"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">isAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"If `e` is of the form `op e₁ e₂` where `op` is an associative and commutative binary operator,\nreturn the canonical form of `op`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.isAC","kind":"def","line":518,"name":"Mathlib.Tactic.CC.CCM.isAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L518-L544"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeACVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">internalizeACVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"If `e` isn't an AC variable, set `e` as a new AC variable. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.internalizeACVar","kind":"def","line":508,"name":"Mathlib.Tactic.CC.CCM.internalizeACVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L508-L516"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setACVar\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">setACVar</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"If the root expression of `e` is AC variable, add equality to AC module. If not, register the\nAC variable to the root entry. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.setACVar","kind":"def","line":497,"name":"Mathlib.Tactic.CC.CCM.setACVar","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L497-L506"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addACEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addACEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e₁ </span><span class=\"fn\">e₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given AC variables `e₁` and `e₂` which are in the same equivalence class, add the proof of\n`e₁ = e₂` to the AC module. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addACEq","kind":"def","line":489,"name":"Mathlib.Tactic.CC.CCM.addACEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L489-L495"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">processAC</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Process the tasks in the `acTodo` field. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.processAC","kind":"def","line":436,"name":"Mathlib.Tactic.CC.CCM.processAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L436-L487"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.superposeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">superposeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ts </span><span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tsEqa</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given `tsEqa : ts = a`, for each equality `trEqb : tr = b` in `acR` where\nthe intersection `t` of `ts` and `tr` is nonempty, let `ts = t*s` and `tr := t*r`, add a new\nequality `r*a = s*b`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.superposeAC","kind":"def","line":397,"name":"Mathlib.Tactic.CC.CCM.superposeAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L397-L434"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSuperposeProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkACSuperposeProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ra </span><span class=\"fn\">sb </span><span class=\"fn\">a </span><span class=\"fn\">b </span><span class=\"fn\">r </span><span class=\"fn\">s </span><span class=\"fn\">ts </span><span class=\"fn\">tr</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">tsEqa </span><span class=\"fn\">trEqb</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a></span></div></div>","info":{"doc":"Given `ra := a*r` `sb := b*s` `ts := t*s` `tr := t*r` `tsEqa : t*s = a` `trEqb : t*r = b`,\nreturn a proof for `ra = sb`.\n\nWe use `a*b` to denote an AC application. That is, `(a*b)*(c*a)` is the term `a*a*b*c`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkACSuperposeProof","kind":"def","line":370,"name":"Mathlib.Tactic.CC.CCM.mkACSuperposeProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L370-L395"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collapseAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">collapseAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Try to simplify the left-hand sides of equalities in `acR` by `H : lhs = rhs`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.collapseAC","kind":"def","line":346,"name":"Mathlib.Tactic.CC.CCM.collapseAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L346-L368"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.composeAC\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">composeAC</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.DelayedExpr\">DelayedExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Try to simplify the right-hand sides of equalities in `acR` by `H : lhs = rhs`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.composeAC","kind":"def","line":323,"name":"Mathlib.Tactic.CC.CCM.composeAC","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L323-L344"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseRRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Erase `lhs` to the occurrences of arguments of `e` on the right-hand side of\nan equality in `acR`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRRHSOccs","kind":"def","line":317,"name":"Mathlib.Tactic.CC.CCM.eraseRRHSOccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L317-L321"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRRHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertRRHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Insert `lhs` to the occurrences of arguments of `e` on the right-hand side of\nan equality in `acR`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRRHSOccs","kind":"def","line":311,"name":"Mathlib.Tactic.CC.CCM.insertRRHSOccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L311-L315"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRBHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseRBHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Erase `lhs` to the occurrences on an equality in `acR` corresponding to the equality\n`lhs := rhs`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseRBHSOccs","kind":"def","line":304,"name":"Mathlib.Tactic.CC.CCM.eraseRBHSOccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L304-L309"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRBHSOccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertRBHSOccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Insert `lhs` to the occurrences on an equality in `acR` corresponding to the equality\n`lhs := rhs`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertRBHSOccs","kind":"def","line":297,"name":"Mathlib.Tactic.CC.CCM.insertRBHSOccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L297-L302"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">eraseROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Erase `lhs` to the occurrences of arguments of `e` on an equality in `acR`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.eraseROccs","kind":"def","line":292,"name":"Mathlib.Tactic.CC.CCM.eraseROccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L292-L295"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Insert `lhs` to the occurrences of arguments of `e` on an equality in `acR`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertROccs","kind":"def","line":287,"name":"Mathlib.Tactic.CC.CCM.insertROccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L287-L290"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROccs\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertEraseROccs</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e </span><span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS </span><span class=\"fn\">isInsert</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Insert or erase `lhs` to the occurrences of arguments of `e` on an equality in `acR`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROccs","kind":"def","line":277,"name":"Mathlib.Tactic.CC.CCM.insertEraseROccs","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L277-L285"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROcc\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">insertEraseROcc</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">arg</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inLHS </span><span class=\"fn\">isInsert</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Insert or erase `lhs` to the occurrences of `arg` on an equality in `acR`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.insertEraseROcc","kind":"def","line":268,"name":"Mathlib.Tactic.CC.CCM.insertEraseROcc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L268-L275"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACState\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">dbgTraceACState</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Trace the state of AC module. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACState","kind":"def","line":263,"name":"Mathlib.Tactic.CC.CCM.dbgTraceACState","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L263-L266"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">dbgTraceACEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">header</span> : <a href=\"./Init/Prelude.html#String\">String</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACApps\">ACApps</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given `lhs`, `rhs`, and `header := \"my header:\"`, Trace `my header: lhs = rhs`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.dbgTraceACEq","kind":"def","line":256,"name":"Mathlib.Tactic.CC.CCM.dbgTraceACEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L256-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBeta\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateBeta</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">fn</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">revArgs </span><span class=\"fn\">lambdas</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">newLambdaApps</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Remove `fn` and expressions whose type isn't def-eq to `fn`'s type out from `lambdas`,\nreturn the remaining lambdas applied to the reversed arguments. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateBeta","kind":"def","line":243,"name":"Mathlib.Tactic.CC.CCM.propagateBeta","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L243-L254"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqcLambdas\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getEqcLambdas</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span> := <a href=\"./Init/Prelude.html#List.toArray\">#[</a><a href=\"./Init/Prelude.html#List.toArray\">]</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span></div></div>","info":{"doc":"Get all lambda expressions in the equivalence class of `e` and append to `r`.\n\n`e` must be the root of its equivalence class. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getEqcLambdas","kind":"def","line":226,"name":"Mathlib.Tactic.CC.CCM.getEqcLambdas","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L226-L241"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkNewSubsingletonEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">oldRoot </span><span class=\"fn\">newRoot</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given the equivalent expressions `oldRoot` and `newRoot` the root of `oldRoot` is\n`newRoot`, if `oldRoot` has root representative of subsingletons, try to push the equality proof\nbetween their root representatives to the todo list, or update the root representative to\n`newRoot`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq","kind":"def","line":212,"name":"Mathlib.Tactic.CC.CCM.checkNewSubsingletonEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L212-L224"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushSubsingletonEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushSubsingletonEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given subsingleton elements `a` and `b` which are not necessarily of the same type, if the\ntypes of `a` and `b` are equivalent, add the (heterogeneous) equality proof between `a` and `b` to\nthe todo list. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushSubsingletonEq","kind":"def","line":195,"name":"Mathlib.Tactic.CC.CCM.pushSubsingletonEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L195-L210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addSymmCongruenceTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addSymmCongruenceTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"If the symm congruence table (`symmCongruences` field) has congruent expression to `e`, add the\nequality to the todo list. If not, add `e` to the symm congruence table. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addSymmCongruenceTable","kind":"def","line":164,"name":"Mathlib.Tactic.CC.CCM.addSymmCongruenceTable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L164-L193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addCongruenceTable\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addCongruenceTable</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"If the congruence table (`congruences` field) has congruent expression to `e`, add the\nequality to the todo list. If not, add `e` to the congruence table. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addCongruenceTable","kind":"def","line":140,"name":"Mathlib.Tactic.CC.CCM.addCongruenceTable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L140-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkEqTrue\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">checkEqTrue</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Given `e := R lhs rhs`, if `R` is a reflexive relation and `lhs` is equivalent to `rhs`, add\nequality `e = True`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.checkEqTrue","kind":"def","line":129,"name":"Mathlib.Tactic.CC.CCM.checkEqTrue","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L129-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymm\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">compareSymm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k₁ </span><span class=\"fn\">k₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Given ``k₁ := (R₁ lhs₁ rhs₁, `R₁)`` and ``k₂ := (R₂ lhs₂ rhs₂, `R₂)``, return `true` if\n`R₁ lhs₁ rhs₁` is equivalent to `R₂ lhs₂ rhs₂` modulo the symmetry of `R₁` and `R₂`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymm","kind":"def","line":117,"name":"Mathlib.Tactic.CC.CCM.compareSymm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L117-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymmAux\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">compareSymmAux</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs₁ </span><span class=\"fn\">rhs₁ </span><span class=\"fn\">lhs₂ </span><span class=\"fn\">rhs₂</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Auxiliary function for comparing `lhs₁ ~ rhs₁` and `lhs₂ ~ rhs₂`,\nwhen `~` is symmetric/commutative.\nIt returns `true` (equal) for `a ~ b` `b ~ a`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.compareSymmAux","kind":"def","line":105,"name":"Mathlib.Tactic.CC.CCM.compareSymmAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L105-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkSymmCongruencesKey</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.SymmCongruencesKey\">SymmCongruencesKey</a></span></div></div>","info":{"doc":"Return the `SymmCongruencesKey` associated with the equality `lhs = rhs`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey","kind":"def","line":99,"name":"Mathlib.Tactic.CC.CCM.mkSymmCongruencesKey","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L99-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongruencesKey\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">mkCongruencesKey</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.CongruencesKey\">CongruencesKey</a></span></div></div>","info":{"doc":"Return the `CongruencesKey` associated with an expression of the form `f a`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.mkCongruencesKey","kind":"def","line":89,"name":"Mathlib.Tactic.CC.CCM.mkCongruencesKey","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L89-L97"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateInstImplicit\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">propagateInstImplicit</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Record the instance `e` and add it to the set of known defeq instances. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.propagateInstImplicit","kind":"def","line":73,"name":"Mathlib.Tactic.CC.CCM.propagateInstImplicit","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L73-L87"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addOccurrence\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">addOccurrence</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">parent </span><span class=\"fn\">child</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">symmTable</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Update the `child` so its parent becomes `parent`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.addOccurrence","kind":"def","line":64,"name":"Mathlib.Tactic.CC.CCM.addOccurrence","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L64-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushReflEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushReflEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add `rfl : lhs = rhs` to the todo list. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushReflEq","kind":"def","line":59,"name":"Mathlib.Tactic.CC.CCM.pushReflEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L59-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushHEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushHEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add the heterogeneous equality proof `H : lhs ≍ rhs` to the end of the todo list. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushHEq","kind":"def","line":54,"name":"Mathlib.Tactic.CC.CCM.pushHEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L54-L57"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushEq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushEq</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add the equality proof `H : lhs = rhs` to the end of the todo list. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushEq","kind":"def","line":49,"name":"Mathlib.Tactic.CC.CCM.pushEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L49-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">pushTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lhs </span><span class=\"fn\">rhs</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.EntryExpr\">EntryExpr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">heqProof</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Add a new entry to the end of the todo list.\n\nSee also `pushEq`, `pushHEq` and `pushReflEq`. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.pushTodo","kind":"def","line":43,"name":"Mathlib.Tactic.CC.CCM.pushTodo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L43-L47"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getACTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getACTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a>)</span></span></div></div>","info":{"doc":"Read the `acTodo` field of the state. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getACTodo","kind":"def","line":38,"name":"Mathlib.Tactic.CC.CCM.getACTodo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L38-L41"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">getTodo</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <span class=\"fn\">(<a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a>)</span></span></div></div>","info":{"doc":"Read the `todo` field of the state. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.getTodo","kind":"def","line":33,"name":"Mathlib.Tactic.CC.CCM.getTodo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L33-L36"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyACTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyACTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.ACTodoEntry\">ACTodoEntry</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Update the `acTodo` field of the state. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyACTodo","kind":"def","line":28,"name":"Mathlib.Tactic.CC.CCM.modifyACTodo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L28-L31"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyTodo\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">CC</span>.<span class=\"name\">CCM</span>.<span class=\"name\">modifyTodo</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Mathlib/Tactic/CC/Datatypes.html#Mathlib.Tactic.CC.TodoEntry\">TodoEntry</a></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/CC/MkProof.html#Mathlib.Tactic.CC.CCM\">CCM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Update the `todo` field of the state. ","docLink":"./Mathlib/Tactic/CC/Addition.html#Mathlib.Tactic.CC.CCM.modifyTodo","kind":"def","line":23,"name":"Mathlib.Tactic.CC.CCM.modifyTodo","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CC/Addition.lean#L23-L26"}}],"imports":["Init","Mathlib.Data.Option.Defs","Mathlib.Tactic.CC.MkProof"],"instances":[],"name":"Mathlib.Tactic.CC.Addition"}