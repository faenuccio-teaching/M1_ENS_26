{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_lightProfinite_internallyProjective_iff_tensor_condition'\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">free_lightProfinite_internallyProjective_iff_tensor_condition'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Preadditive/Projective/Internal.html#CategoryTheory.InternallyProjective\">CategoryTheory.InternallyProjective</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">P</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ {<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>} (<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>) [<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">e</span></span>] (<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)\n    (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">S</span> <span class=\"fn\">P</span>)</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>),\n    <span class=\"fn\">∃ (<span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>) (<span class=\"fn\">π</span> : <span class=\"fn\">S'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">⇑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">π</span>)</span></span></span>) (<span class=\"fn\">g'</span> :\n      <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">S'</span> <span class=\"fn\">P</span>)</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">A</span>),\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n          <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerRight\">CategoryTheory.MonoidalCategoryStruct.whiskerRight</a> <span class=\"fn\">π</span> <span class=\"fn\">P</span>)</span>)</span>)</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"Given a `P : LightProfinite`, the light free light condensed module `R[P]` is internally projective\nif and only if, for all `A B : LightCondMod R`, for all epimorphisms `e : A ⟶ B`, for all\n`S : LightProfinite` and all morphisms `g : R[S × P] ⟶ B`, there exists a `S' : LightProfinite`\nwith a surjeciton `π : S' ⟶ S` and a morphism `g' : R[S' × P] ⟶ A`, making the diagram\n```\nR[S' × P] --> A\n  |           |\n  v           v\nR[S × P]  --> B\n```\ncommute.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_lightProfinite_internallyProjective_iff_tensor_condition'","kind":"theorem","line":265,"name":"LightCondensed.free_lightProfinite_internallyProjective_iff_tensor_condition'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L265-L297"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_lightProfinite_internallyProjective_iff_tensor_condition\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">free_lightProfinite_internallyProjective_iff_tensor_condition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Preadditive/Projective/Internal.html#CategoryTheory.InternallyProjective\">CategoryTheory.InternallyProjective</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">P</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ {<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>} (<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>) [<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">e</span></span>] (<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)\n    (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S</span>)</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>),\n    <span class=\"fn\">∃ (<span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>) (<span class=\"fn\">π</span> : <span class=\"fn\">S'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">⇑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">π</span>)</span></span></span>) (<span class=\"fn\">g'</span> :\n      <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\">S'</span>)</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">A</span>),\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n          <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerLeft\">CategoryTheory.MonoidalCategoryStruct.whiskerLeft</a> <span class=\"fn\">P</span> <span class=\"fn\">π</span>)</span>)</span>)</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"Given a `P : LightProfinite`, the light free light condensed module `R[P]` is internally projective\nif and only if, for all `A B : LightCondMod R`, for all epimorphisms `e : A ⟶ B`, for all\n`S : LightProfinite` and all morphisms `g : R[P × S] ⟶ B`, there exists a `S' : LightProfinite`\nwith a surjeciton `π : S' ⟶ S` and a morphism `g' : R[P × S'] ⟶ A`, making the diagram\n```\nR[P × S'] --> A\n  |           |\n  v           v\nR[P × S]  --> B\n```\ncommute.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_lightProfinite_internallyProjective_iff_tensor_condition","kind":"theorem","line":231,"name":"LightCondensed.free_lightProfinite_internallyProjective_iff_tensor_condition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L231-L263"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_internallyProjective_iff_tensor_condition'\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">free_internallyProjective_iff_tensor_condition'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <a href=\"./Mathlib/Condensed/Light/Basic.html#LightCondSet\">LightCondSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Preadditive/Projective/Internal.html#CategoryTheory.InternallyProjective\">CategoryTheory.InternallyProjective</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">P</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ {<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>} (<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>) [<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">e</span></span>] (<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)\n    (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\"><span class=\"fn\">S</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span> <span class=\"fn\">P</span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>),\n    <span class=\"fn\">∃ (<span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>) (<span class=\"fn\">π</span> : <span class=\"fn\">S'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">⇑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">π</span>)</span></span></span>) (<span class=\"fn\">g'</span> :\n      <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\"><span class=\"fn\">S'</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span> <span class=\"fn\">P</span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">A</span>),\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n          <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerRight\">CategoryTheory.MonoidalCategoryStruct.whiskerRight</a> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">π</span>)</span> <span class=\"fn\">P</span>)</span>)</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"Given a `P : LightCondSet`, the light free light condensed module `R[P]` is internally projective if\nand only if, for all `A B : LightCondMod R`, for all epimorphisms `e : A ⟶ B`, for all\n`S : LightProfinite` and all morphisms `g : R[S × P] ⟶ B`, there exists a `S' : LightProfinite`\nwith a surjeciton `π : S' ⟶ S` and a morphism `g' : R[S' × P] ⟶ A`, making the diagram\n```\nR[S' × P] --> A\n  |           |\n  v           v\nR[S × P]  --> B\n```\ncommute.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_internallyProjective_iff_tensor_condition'","kind":"theorem","line":195,"name":"LightCondensed.free_internallyProjective_iff_tensor_condition'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L195-L229"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_internallyProjective_iff_tensor_condition\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">free_internallyProjective_iff_tensor_condition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <a href=\"./Mathlib/Condensed/Light/Basic.html#LightCondSet\">LightCondSet</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Preadditive/Projective/Internal.html#CategoryTheory.InternallyProjective\">CategoryTheory.InternallyProjective</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">P</span>)</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ {<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>} (<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>) [<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">e</span></span>] (<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)\n    (<span class=\"fn\">g</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>),\n    <span class=\"fn\">∃ (<span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>) (<span class=\"fn\">π</span> : <span class=\"fn\">S'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">⇑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">π</span>)</span></span></span>) (<span class=\"fn\">g'</span> :\n      <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\"><span class=\"fn\">S'</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">A</span>),\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n          <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerLeft\">CategoryTheory.MonoidalCategoryStruct.whiskerLeft</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">π</span>)</span>)</span>)</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"Given a `P : LightCondSet`, the light free light condensed module `R[P]` is internally projective if\nand only if, for all `A B : LightCondMod R`, for all epimorphisms `e : A ⟶ B`, for all\n`S : LightProfinite` and all morphisms `g : R[P × S] ⟶ B`, there exists a `S' : LightProfinite`\nwith a surjeciton `π : S' ⟶ S` and a morphism `g' : R[P × S'] ⟶ A`, making the diagram\n```\nR[P × S'] --> A\n  |           |\n  v           v\nR[P × S]  --> B\n```\ncommute.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.free_internallyProjective_iff_tensor_condition","kind":"theorem","line":158,"name":"LightCondensed.free_internallyProjective_iff_tensor_condition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L158-L193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.internallyProjective_iff_tensor_condition'\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">internallyProjective_iff_tensor_condition'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Preadditive/Projective/Internal.html#CategoryTheory.InternallyProjective\">CategoryTheory.InternallyProjective</a> <span class=\"fn\">P</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ {<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>} (<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>) [<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">e</span></span>] (<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)\n    (<span class=\"fn\">g</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span> <span class=\"fn\">P</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>),\n    <span class=\"fn\">∃ (<span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>) (<span class=\"fn\">π</span> : <span class=\"fn\">S'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">⇑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">π</span>)</span></span></span>) (<span class=\"fn\">g'</span> :\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S'</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span> <span class=\"fn\">P</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">A</span>),\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n          <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerRight\">CategoryTheory.MonoidalCategoryStruct.whiskerRight</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">π</span>)</span> <span class=\"fn\">P</span>)</span>\n          <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"`P : LightCondMod R` is internally projective if and\nonly if, for all `A B : LightCondMod R`, for all epimorphisms `e : A ⟶ B`, for all\n`S : LightProfinite` and all morphisms `g : R[S] ⊗ P ⟶ B`, there exists a `S' : LightProfinite`\nwith a surjeciton `π : S' ⟶ S` and a morphism `g' : R[S'] ⊗ P ⟶ A`, making the diagram\n```\nR[S'] ⊗ P --> A\n  |           |\n  v           v\nR[S] ⊗ P  --> B\n```\ncommute.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.internallyProjective_iff_tensor_condition'","kind":"theorem","line":129,"name":"LightCondensed.internallyProjective_iff_tensor_condition'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L129-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.internallyProjective_iff_tensor_condition\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">internallyProjective_iff_tensor_condition</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Preadditive/Projective/Internal.html#CategoryTheory.InternallyProjective\">CategoryTheory.InternallyProjective</a> <span class=\"fn\">P</span></span> <a href=\"./Init/Core.html#Iff\">↔</a>   <span class=\"fn\">∀ {<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>} (<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>) [<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Epi\">CategoryTheory.Epi</a> <span class=\"fn\">e</span></span>] (<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)\n    (<span class=\"fn\">g</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>),\n    <span class=\"fn\">∃ (<span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>) (<span class=\"fn\">π</span> : <span class=\"fn\">S'</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S</span>) (_ : <span class=\"fn\"><a href=\"./Init/Data/Function.html#Function.Surjective\">Function.Surjective</a> <span class=\"fn\">⇑<span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">π</span>)</span></span></span>) (<span class=\"fn\">g'</span> :\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S'</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">A</span>),\n      <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n          <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerLeft\">CategoryTheory.MonoidalCategoryStruct.whiskerLeft</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.comp\">comp</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">π</span>)</span>)</span> <span class=\"fn\">g</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>         <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">g'</span> <span class=\"fn\">e</span></span></span></span></div></div>","info":{"doc":"`P : LightCondMod R` is internally projective if and\nonly if, for all `A B : LightCondMod R`, for all epimorphisms `e : A ⟶ B`, for all\n`S : LightProfinite` and all morphisms `g : P ⊗ R[S] ⟶ B`, there exists a `S' : LightProfinite`\nwith a surjeciton `π : S' ⟶ S` and a morphism `g' : P ⊗ R[S'] ⟶ A`, making the diagram\n```\nP ⊗ R[S'] --> A\n  |           |\n  v           v\nP ⊗ R[S]  --> B\n```\ncommute.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.internallyProjective_iff_tensor_condition","kind":"theorem","line":90,"name":"LightCondensed.internallyProjective_iff_tensor_condition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L90-L127"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints_symm_comp\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">ihomPoints_symm_comp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B </span><span class=\"fn\">P</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">S </span><span class=\"fn\">S'</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">π</span> : <span class=\"fn\">S</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">S'</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S'</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\">ihomPoints</a> <span class=\"fn\">R</span> <span class=\"fn\">P</span> <span class=\"fn\">B</span> <span class=\"fn\">S</span>)</span>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span>\n    <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a>\n      <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.whiskerLeft\">CategoryTheory.MonoidalCategoryStruct.whiskerLeft</a> <span class=\"fn\">P</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">(<span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Functors.html#lightProfiniteToLightCondSet\">lightProfiniteToLightCondSet</a>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">π</span>)</span>)</span>)</span> <span class=\"fn\">f</span>)</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">P</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">B</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val\">val</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\"><span class=\"fn\">π</span>.<a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom.op\">op</a></span>)</span>)</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\">ihomPoints</a> <span class=\"fn\">R</span> <span class=\"fn\">P</span> <span class=\"fn\">B</span> <span class=\"fn\">S'</span>)</span>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span> <span class=\"fn\">f</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints_symm_comp","kind":"theorem","line":80,"name":"LightCondensed.ihomPoints_symm_comp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L80-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihom_map_val_app\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">ihom_map_val_app</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A </span><span class=\"fn\">B </span><span class=\"fn\">P</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">A</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">P</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">A</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val\">val</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">S</span>)</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.ConcreteCategory.hom\">CategoryTheory.ConcreteCategory.hom</a> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">P</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.map\">map</a></span> <span class=\"fn\">e</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.Hom.val\">val</a></span>.<a href=\"./Mathlib/CategoryTheory/NatTrans.html#CategoryTheory.NatTrans.app\">app</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">S</span>)</span>)</span>)</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\">ihomPoints</a> <span class=\"fn\">R</span> <span class=\"fn\">P</span> <span class=\"fn\">B</span> <span class=\"fn\">S</span>)</span>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryTheory.CategoryStruct.comp</a> <span class=\"fn\">(<span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\">ihomPoints</a> <span class=\"fn\">R</span> <span class=\"fn\">P</span> <span class=\"fn\">A</span> <span class=\"fn\">S</span>)</span> <span class=\"fn\">x</span>)</span> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihom_map_val_app","kind":"theorem","line":71,"name":"LightCondensed.ihom_map_val_app","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L71-L78"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints_symm_apply\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">ihomPoints_symm_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">A</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\">ihomPoints</a> <span class=\"fn\">R</span> <span class=\"fn\">A</span> <span class=\"fn\">B</span> <span class=\"fn\">S</span>)</span>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology\">CategoryTheory.coherentTopology</a> <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Subcanonical.html#CategoryTheory.GrothendieckTopology.yonedaEquiv\">yonedaEquiv</a></span>\n    <span class=\"fn\">(<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.freeForgetAdjunction\">freeForgetAdjunction</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction.homEquiv\">homEquiv</a></span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology\">CategoryTheory.coherentTopology</a> <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.GrothendieckTopology.yoneda\">yoneda</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">S</span>)</span>\n        <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">A</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">B</span>)</span>)</span>\n      <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.MonoidalClosed.curry\">CategoryTheory.MonoidalClosed.curry</a> <span class=\"fn\">x</span>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints_symm_apply","kind":"theorem","line":65,"name":"LightCondensed.ihomPoints_symm_apply","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L65-L69"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints_apply\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">ihomPoints_apply</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">A</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">B</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val\">val</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">S</span>)</span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\">ihomPoints</a> <span class=\"fn\">R</span> <span class=\"fn\">A</span> <span class=\"fn\">B</span> <span class=\"fn\">S</span>)</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a>   <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.MonoidalClosed.uncurry\">CategoryTheory.MonoidalClosed.uncurry</a>\n    <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.freeForgetAdjunction\">freeForgetAdjunction</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Adjunction/Basic.html#CategoryTheory.Adjunction.homEquiv\">homEquiv</a></span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology\">CategoryTheory.coherentTopology</a> <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Canonical.html#CategoryTheory.GrothendieckTopology.yoneda\">yoneda</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">S</span>)</span>\n          <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">A</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">B</span>)</span>)</span>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span>\n      <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Sites/Coherent/Basic.html#CategoryTheory.coherentTopology\">CategoryTheory.coherentTopology</a> <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Subcanonical.html#CategoryTheory.GrothendieckTopology.yonedaEquiv\">yonedaEquiv</a></span>.<a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv.symm\">symm</a></span> <span class=\"fn\">x</span>)</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints_apply","kind":"theorem","line":59,"name":"LightCondensed.ihomPoints_apply","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L59-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">noncomputable def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints\"><span class=\"name\">LightCondensed</span>.<span class=\"name\">ihomPoints</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#CommRing\">CommRing</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A </span><span class=\"fn\">B</span> : <span class=\"fn\"><a href=\"./Mathlib/Condensed/Light/Module.html#LightCondMod\">LightCondMod</a> <span class=\"fn\">R</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">S</span> : <a href=\"./Mathlib/Topology/Category/LightProfinite/Basic.html#LightProfinite\">LightProfinite</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">(<span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Monoidal/Closed/Basic.html#CategoryTheory.ihom\">CategoryTheory.ihom</a> <span class=\"fn\">A</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">B</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Sites/Sheaf.html#CategoryTheory.Sheaf.val\">val</a></span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Opposite.html#Opposite.op\">Opposite.op</a> <span class=\"fn\">S</span>)</span>)</span></span> <a href=\"./Mathlib/Logic/Equiv/Defs.html#Equiv\">≃</a>   (<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Monoidal/Category.html#CategoryTheory.MonoidalCategoryStruct.tensorObj\">CategoryTheory.MonoidalCategoryStruct.tensorObj</a> <span class=\"fn\">A</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Condensed/Light/Module.html#LightCondensed.free\">free</a> <span class=\"fn\">R</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\"><span class=\"fn\">S</span>.<a href=\"./Mathlib/Condensed/Light/Functors.html#LightProfinite.toCondensed\">toCondensed</a></span>)</span></span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">B</span>)</div></div>","info":{"doc":"The `S`-valued points of the internal hom `A ⟶[LightCondMod R] B` are in bijection with\nmorpisms `A ⊗ R[S] ⟶ B`.\n","docLink":"./Mathlib/Condensed/Light/InternallyProjective.html#LightCondensed.ihomPoints","kind":"def","line":49,"name":"LightCondensed.ihomPoints","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Condensed/Light/InternallyProjective.lean#L49-L57"}}],"imports":["Init","Mathlib.CategoryTheory.Preadditive.Projective.Internal","Mathlib.Condensed.Light.Epi","Mathlib.Condensed.Light.Functors","Mathlib.Condensed.Light.Monoidal"],"instances":[],"name":"Mathlib.Condensed.Light.InternallyProjective"}