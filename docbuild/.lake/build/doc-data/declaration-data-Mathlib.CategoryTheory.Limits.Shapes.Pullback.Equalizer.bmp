{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.html#CategoryTheory.Limits.isPushout_coequalizer_coprod\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isPushout_coequalizer_coprod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasCoequalizer\">HasCoequalizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.HasBinaryCoproduct\">HasBinaryCoproduct</a> <span class=\"fn\">X</span> <span class=\"fn\">X</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.html#CategoryTheory.IsPushout\">IsPushout</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.coprod.desc\">coprod.desc</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.coprod.desc\">coprod.desc</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">X</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">X</span>)</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span>\n  <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.coequalizer.π\">coequalizer.π</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span>)</span></span></div></div>","info":{"doc":"The coequalizer of `f g : X ⟶ Y` is the pushout of the diagonal map `X ⨿ X ⟶ X`\nalong the map `(f, g) : X ⨿ X ⟶ Y`. ","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.html#CategoryTheory.Limits.isPushout_coequalizer_coprod","kind":"theorem","line":38,"name":"CategoryTheory.Limits.isPushout_coequalizer_coprod","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean#L38-L50"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.html#CategoryTheory.Limits.isPullback_equalizer_prod\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">Limits</span>.<span class=\"name\">isPullback_equalizer_prod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v, u}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.HasEqualizer\">HasEqualizer</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.HasBinaryProduct\">HasBinaryProduct</a> <span class=\"fn\">Y</span> <span class=\"fn\">Y</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/CommSq.html#CategoryTheory.IsPullback\">IsPullback</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/Equalizers.html#CategoryTheory.Limits.equalizer.ι\">equalizer.ι</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span> <span class=\"fn\">f</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.prod.lift\">prod.lift</a> <span class=\"fn\">f</span> <span class=\"fn\">g</span>)</span>\n  <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.html#CategoryTheory.Limits.prod.lift\">prod.lift</a> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">Y</span>)</span> <span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.id\">CategoryStruct.id</a> <span class=\"fn\">Y</span>)</span>)</span></span></div></div>","info":{"doc":"The equalizer of `f g : X ⟶ Y` is the pullback of the diagonal map `Y ⟶ Y × Y`\nalong the map `(f, g) : X ⟶ Y × Y`. ","docLink":"./Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.html#CategoryTheory.Limits.isPullback_equalizer_prod","kind":"theorem","line":25,"name":"CategoryTheory.Limits.isPullback_equalizer_prod","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/CategoryTheory/Limits/Shapes/Pullback/Equalizer.lean#L25-L36"}}],"imports":["Init","Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq"],"instances":[],"name":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Equalizer"}