{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Clean.html#Mathlib.Tactic.tacticClean_\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">tacticClean_</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"(Deprecated) `clean t` is a macro for `exact clean% t`. ","docLink":"./Mathlib/Tactic/Clean.html#Mathlib.Tactic.tacticClean_","kind":"def","line":71,"name":"Mathlib.Tactic.tacticClean_","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Clean.lean#L71-L71"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Clean.html#Mathlib.Tactic.elabClean\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">elabClean</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElab\">Lean.Elab.Term.TermElab</a></div></div>","info":{"doc":"`clean% t` fully elaborates `t` and then eliminates all identity functions from it.\n\nIdentity functions are normally generated with terms like `show t from p`,\nwhich translate to some variant on `@id t p` in order to retain the type.\nThese are also generated by tactics such as `dsimp` to insert type hints.\n\nExample:\n```lean\ndef x : Id Nat := by dsimp [Id]; exact 1\n#print x\n-- def x : Id Nat := id 1\n\ndef x' : Id Nat := clean% by dsimp [Id]; exact 1\n#print x'\n-- def x' : Id Nat := 1\n```\n","docLink":"./Mathlib/Tactic/Clean.html#Mathlib.Tactic.elabClean","kind":"def","line":62,"name":"Mathlib.Tactic.elabClean","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Clean.lean#L62-L68"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Clean.html#Mathlib.Tactic.cleanStx\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">cleanStx</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`clean% t` fully elaborates `t` and then eliminates all identity functions from it.\n\nIdentity functions are normally generated with terms like `show t from p`,\nwhich translate to some variant on `@id t p` in order to retain the type.\nThese are also generated by tactics such as `dsimp` to insert type hints.\n\nExample:\n```lean\ndef x : Id Nat := by dsimp [Id]; exact 1\n#print x\n-- def x : Id Nat := id 1\n\ndef x' : Id Nat := clean% by dsimp [Id]; exact 1\n#print x'\n-- def x' : Id Nat := 1\n```\n","docLink":"./Mathlib/Tactic/Clean.html#Mathlib.Tactic.cleanStx","kind":"def","line":42,"name":"Mathlib.Tactic.cleanStx","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Clean.lean#L42-L60"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Clean.html#Lean.Expr.clean\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">clean</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Expr.html#Lean.Expr\">Expr</a></div></div>","info":{"doc":"Clean an expression by eliminating identify functions listed in `cleanConsts`.\nAlso eliminates `fun x => x` applications and tautological `let`/`have` bindings. ","docLink":"./Mathlib/Tactic/Clean.html#Lean.Expr.clean","kind":"def","line":29,"name":"Lean.Expr.clean","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Clean.lean#L29-L36"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Clean.html#Lean.Expr.cleanConsts\"><span class=\"name\">Lean</span>.<span class=\"name\">Expr</span>.<span class=\"name\">cleanConsts</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Name</a></span></div></div>","info":{"doc":"List of names removed by the `clean` tactic.\nAll of these names must resolve to functions defeq `id`. ","docLink":"./Mathlib/Tactic/Clean.html#Lean.Expr.cleanConsts","kind":"def","line":23,"name":"Lean.Expr.cleanConsts","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Clean.lean#L23-L27"}}],"imports":["Init","Mathlib.Init","Lean.Elab.SyntheticMVars"],"instances":[],"name":"Mathlib.Tactic.Clean"}