{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image\"><span class=\"name\">Ordnode</span>.<span class=\"name\">image</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_3}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">β</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></div></div>","info":{"doc":"O(n * log n). Map a function on a set. Unlike `map` this has no requirements on\n`f`, and the resulting set may be smaller than the input if `f` is noninjective.\nEquivalent elements are selected with a preference for smaller source elements.\n\n    image (fun x ↦ x + 2) {1, 2, 4} = {3, 4, 6}\n    image (fun x : ℕ ↦ x - 2) {1, 2, 4} = {0, 2} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.image","kind":"def","line":1203,"name":"Ordnode.image","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1203-L1210"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofList'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(n * log n). Adaptively chooses between the linear and log-linear algorithm depending\non whether the input list is already sorted.\n\n  ofList' [1, 2, 3] = {1, 2, 3}\n  ofList' [2, 1, 1, 3] = {1, 2, 3} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList'","kind":"def","line":1194,"name":"Ordnode.ofList'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1194-L1201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(n * log n). Build a set from a list, preferring elements that appear earlier in the list\nin the case of equivalent elements.\n\n    ofList [1, 2, 3] = {1, 2, 3}\n    ofList [2, 1, 1, 3] = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    ofList [(1, 1), (0, 1), (1, 2)] = {(0, 1), (1, 1)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofList","kind":"def","line":1182,"name":"Ordnode.ofList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1182-L1192"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">inter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Intersection of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n    inter {1, 2} {2, 3} = {2}\n    inter {1, 3} {2} = ∅ ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.inter","kind":"def","line":1168,"name":"Ordnode.inter","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1168-L1180"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff\"><span class=\"name\">Ordnode</span>.<span class=\"name\">diff</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. Difference of two sets.\n\ndiff {1, 2} {2, 3} = {1}\ndiff {1, 2, 3} {2} = {1, 3} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.diff","kind":"def","line":1155,"name":"Ordnode.diff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1155-L1166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union\"><span class=\"name\">Ordnode</span>.<span class=\"name\">union</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(m * log(|m ∪ n| + 1)), m ≤ n. The union of two sets, preferring members of\n`t₁` over those of `t₂` when equivalent elements are encountered.\n\n  union {1, 2} {2, 3} = {1, 2, 3}\n  union {1, 3} {2} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n  union {(1, 1)} {(0, 1), (1, 2)} = {(0, 1), (1, 1)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.union","kind":"def","line":1135,"name":"Ordnode.union","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1135-L1153"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint\"><span class=\"name\">Ordnode</span>.<span class=\"name\">disjoint</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"O(m + n). Is every element of `t₁` not equivalent to any element of `t₂`?\n\ndisjoint {1, 3} {2, 4} = tt\ndisjoint {1, 2} {2, 4} = ff ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.disjoint","kind":"def","line":1124,"name":"Ordnode.disjoint","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1124-L1133"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset\"><span class=\"name\">Ordnode</span>.<span class=\"name\">isSubset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Bool\">Bool</a></div></div>","info":{"doc":"O(m + n). Is every element of `t₁` equivalent to some element of `t₂`?\n\nis_subset {1, 4} {1, 2, 4} = tt\nis_subset {1, 3} {1, 2, 4} = ff ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubset","kind":"def","line":1117,"name":"Ordnode.isSubset","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1117-L1122"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">isSubsetAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"Auxiliary definition for `isSubset`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.isSubsetAux","kind":"def","line":1109,"name":"Ordnode.isSubsetAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1109-L1115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findIndex</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"O(log n). Get the index, counting from the left,\nof an element equivalent to `x` if it exists.\n\n    findIndex 2 {1, 2, 4} = some 1\n    findIndex 4 {1, 2, 4} = some 2\n    findIndex 5 {1, 2, 4} = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndex","kind":"def","line":1100,"name":"Ordnode.findIndex","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1100-L1107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findIndexAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></span></span></div></div>","info":{"doc":"Auxiliary definition for `findIndex`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findIndexAux","kind":"def","line":1091,"name":"Ordnode.findIndexAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1091-L1098"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Get the smallest element in the tree that is `≥ x`.\n\nfindGe 2 {1, 2, 4} = some 2\nfindGe 3 {1, 2, 4} = some 4\nfindGe 5 {1, 2, 4} = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGe","kind":"def","line":1078,"name":"Ordnode.findGe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1078-L1089"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"Auxiliary definition for `findGe`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGeAux","kind":"def","line":1069,"name":"Ordnode.findGeAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1069-L1076"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLe</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Get the largest element in the tree that is `≤ x`.\n\nfindLe 2 {1, 2, 4} = some 2\nfindLe 3 {1, 2, 4} = some 2\nfindLe 0 {1, 2, 4} = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLe","kind":"def","line":1056,"name":"Ordnode.findLe","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1056-L1067"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"Auxiliary definition for `findLe`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLeAux","kind":"def","line":1047,"name":"Ordnode.findLeAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1047-L1054"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Get the smallest element in the tree that is `> x`.\n\nfindGt 2 {1, 2, 4} = some 4\nfindGt 3 {1, 2, 4} = some 4\nfindGt 4 {1, 2, 4} = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGt","kind":"def","line":1038,"name":"Ordnode.findGt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1038-L1045"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findGtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"Auxiliary definition for `findGt`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findGtAux","kind":"def","line":1033,"name":"Ordnode.findGtAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1033-L1036"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Get the largest element in the tree that is `< x`.\n\nfindLt 2 {1, 2, 4} = some 1\nfindLt 3 {1, 2, 4} = some 2\nfindLt 0 {1, 2, 4} = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLt","kind":"def","line":1024,"name":"Ordnode.findLt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1024-L1031"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findLtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"Auxiliary definition for `findLt`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findLtAux","kind":"def","line":1019,"name":"Ordnode.findLtAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1019-L1022"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase\"><span class=\"name\">Ordnode</span>.<span class=\"name\">erase</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Remove an element from the set equivalent to `x`. Does nothing if there\nis no such element.\n\n    erase 1 {1, 2, 3} = {2, 3}\n    erase 4 {1, 2, 3} = {1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    erase (1, 1) {(0, 1), (1, 2)} = {(0, 1)}\n    erase (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.erase","kind":"def","line":1001,"name":"Ordnode.erase","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L1001-L1017"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3\"><span class=\"name\">Ordnode</span>.<span class=\"name\">split3</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Split the tree into those smaller than `x` and those greater than it,\nplus an element equivalent to `x`, if it exists.\n\n    split3 2 {1, 2, 4} = ({1}, some 2, {4})\n    split3 3 {1, 2, 4} = ({1, 2}, none, {4})\n    split3 4 {1, 2, 4} = ({1, 2}, some 4, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split3 (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, some (1, 2), ∅)\n    split3 (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, none, ∅) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split3","kind":"def","line":978,"name":"Ordnode.split3","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L978-L999"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split\"><span class=\"name\">Ordnode</span>.<span class=\"name\">split</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Split the tree into those smaller than `x` and those greater than it.\nIf an element equivalent to `x` is in the set, it is discarded.\n\n    split 2 {1, 2, 4} = ({1}, {4})\n    split 3 {1, 2, 4} = ({1, 2}, {4})\n    split 4 {1, 2, 4} = ({1, 2}, ∅)\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    split (1, 1) {(0, 1), (1, 2)} = ({(0, 1)}, ∅)\n    split (3, 1) {(0, 1), (1, 2)} = ({(0, 1), (1, 2)}, ∅) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.split","kind":"def","line":955,"name":"Ordnode.split","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L955-L976"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insert'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the set is returned as is.\n\n    insert' 1 {1, 2, 3} = {1, 2, 3}\n    insert' 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert' (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)}\n    insert' (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert'","kind":"def","line":937,"name":"Ordnode.insert'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L937-L953"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instInsert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Insert\">Insert</a> <span class=\"fn\">α</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInsert","kind":"instance","line":934,"name":"Ordnode.instInsert","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L934-L935"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insert</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, this replaces it.\n\n    insert 1 {1, 2, 3} = {1, 2, 3}\n    insert 4 {1, 2, 3} = {1, 2, 3, 4}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insert (1, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 1)}\n    insert (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insert","kind":"def","line":916,"name":"Ordnode.insert","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L916-L932"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">alter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    alter f 0 {1, 2, 3} = {1, 2, 3}     if f none = none\n                        = {a, 1, 2, 3}  if f none = some a\n    alter f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                        = {a, 2, 3}  if f 1 = some a ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.alter","kind":"def","line":897,"name":"Ordnode.alter","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L897-L914"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">updateWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    updateWith f 0 {1, 2, 3} = {1, 2, 3}\n    updateWith f 1 {1, 2, 3} = {2, 3}     if f 1 = none\n                              = {a, 2, 3}  if f 1 = some a ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.updateWith","kind":"def","line":879,"name":"Ordnode.updateWith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L879-L895"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">adjustWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Modify an element in the set with the given function,\ndoing nothing if the key is not found.\nNote that the element returned by `f` must be equivalent to `x`.\n\n    adjustWith f 0 {1, 2, 3} = {1, 2, 3}\n    adjustWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    adjustWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    adjustWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.adjustWith","kind":"def","line":860,"name":"Ordnode.adjustWith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L860-L877"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertWith</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Insert an element into the set, preserving balance and the BST property.\nIf an equivalent element is already in the set, the function `f` is used to generate\nthe element to insert (being passed the current value in the set).\n\n    insertWith f 0 {1, 2, 3} = {0, 1, 2, 3}\n    insertWith f 1 {1, 2, 3} = {f 1, 2, 3}\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    insertWith f (1, 1) {(0, 1), (1, 2)} = {(0, 1), f (1, 2)}\n    insertWith f (3, 1) {(0, 1), (1, 2)} = {(0, 1), (1, 2), (3, 1)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertWith","kind":"def","line":841,"name":"Ordnode.insertWith","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L841-L858"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">mem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> (<span class=\"fn\">x</span> <a href=\"./Init/Prelude.html#Membership.mem\">∈</a> <span class=\"fn\">t</span>)</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem.decidable","kind":"instance","line":838,"name":"Ordnode.mem.decidable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L838-L839"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instMembership</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Membership\">Membership</a> <span class=\"fn\">α</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instMembership","kind":"instance","line":835,"name":"Ordnode.instMembership","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L835-L836"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find\"><span class=\"name\">Ordnode</span>.<span class=\"name\">find</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Retrieve an element in the set that is equivalent to `x` in the order,\nif it exists.\n\n    find 1 {1, 2, 3} = some 1\n    find 4 {1, 2, 3} = none\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    find (1, 1) {(0, 1), (1, 2)} = some (1, 2)\n    find (3, 1) {(0, 1), (1, 2)} = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.find","kind":"def","line":817,"name":"Ordnode.find","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L817-L833"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">mem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"O(log n). Does the set (approximately) contain the element `x`? That is,\nis there an element that is equivalent to `x` in the order?\n\n    1 ∈ {1, 2, 3} = true\n    4 ∈ {1, 2, 3} = false\n\nUsing a preorder on `ℕ × ℕ` that only compares the first coordinate:\n\n    (1, 1) ∈ {(0, 1), (1, 2)} = true\n    (3, 1) ∈ {(0, 1), (1, 2)} = false ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.mem","kind":"def","line":799,"name":"Ordnode.mem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L799-L815"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(n). Build a set from a list which is already sorted. Performs no comparisons.\n\nofAscList [1, 2, 3] = {1, 2, 3}\nofAscList [3, 2, 1] = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscList","kind":"def","line":787,"name":"Ordnode.ofAscList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L787-L793"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscListAux₂</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>","info":{"doc":"Auxiliary definition for `ofAscList`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₂","kind":"def","line":777,"name":"Ordnode.ofAscListAux₂","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L777-L785"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ofAscListAux₁</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Subtype\">{</a> <span class=\"fn\">l'</span> <a href=\"./Init/Prelude.html#Subtype\">:</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Subtype\">//</a> <span class=\"fn\"><span class=\"fn\">l'</span>.<a href=\"./Init/Prelude.html#List.length\">length</a></span> <a href=\"./Init/Prelude.html#LE.le\">≤</a> <span class=\"fn\"><span class=\"fn\">l</span>.<a href=\"./Init/Prelude.html#List.length\">length</a></span> <a href=\"./Init/Prelude.html#Subtype\">}</a></span></div></div>","info":{"doc":"Auxiliary definition for `ofAscList`.\n\n**Note:** This function is defined by well-founded recursion, so it will probably not compute\nin the kernel, meaning that you probably can't prove things like\n`ofAscList [1, 2, 3] = {1, 2, 3}` by `rfl`.\nThis implementation is optimized for VM evaluation. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ofAscListAux₁","kind":"def","line":758,"name":"Ordnode.ofAscListAux₁","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L758-L775"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span\"><span class=\"name\">Ordnode</span>.<span class=\"name\">span</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Split the set into those satisfying and not satisfying the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    span (fun x ↦ x < 4) {1, 2, 3, 4, 5} = ({1, 2, 3}, {4, 5})\n    span (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.span","kind":"def","line":743,"name":"Ordnode.span","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L743-L756"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dropWhile</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Remove an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    dropWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {4, 5}\n    dropWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropWhile","kind":"def","line":734,"name":"Ordnode.dropWhile","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L734-L741"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile\"><span class=\"name\">Ordnode</span>.<span class=\"name\">takeWhile</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Get an initial segment of the set that satisfies the predicate `p`.\n`p` is required to be antitone, that is, `x < y → p y → p x`.\n\n    takeWhile (fun x ↦ x < 4) {1, 2, 3, 4, 5} = {1, 2, 3}\n    takeWhile (fun x ↦ x > 4) {1, 2, 3, 4, 5} = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeWhile","kind":"def","line":725,"name":"Ordnode.takeWhile","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L725-L732"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitAt</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(log n). Split a set at the `i`th element, getting the first `i` and everything else.\n\nsplitAt 2 {a, b, c, d} = ({a, b}, {c, d})\nsplitAt 5 {a, b, c, d} = ({a, b, c, d}, ∅) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAt","kind":"def","line":718,"name":"Ordnode.splitAt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L718-L723"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitAtAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"Auxiliary definition for `splitAt`. (Can also be used in lieu of `splitAt` if you know the\nindex is within the range of the data structure.)\n\n    splitAtAux {a, b, c, d} 2 = ({a, b}, {c, d})\n    splitAtAux {a, b, c, d} 5 = ({a, b, c, d}, ∅) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitAtAux","kind":"def","line":699,"name":"Ordnode.splitAtAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L699-L716"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop\"><span class=\"name\">Ordnode</span>.<span class=\"name\">drop</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(log n). Remove the first `i` elements of the set, counted from the left.\n\ndrop 2 {a, b, c, d} = {c, d}\ndrop 5 {a, b, c, d} = ∅ ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.drop","kind":"def","line":692,"name":"Ordnode.drop","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L692-L697"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dropAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"Auxiliary definition for `drop`. (Can also be used in lieu of `drop` if you know the\nindex is within the range of the data structure.)\n\n    drop_aux {a, b, c, d} 2 = {c, d}\n    drop_aux {a, b, c, d} 5 = ∅ ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dropAux","kind":"def","line":677,"name":"Ordnode.dropAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L677-L690"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take\"><span class=\"name\">Ordnode</span>.<span class=\"name\">take</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">i</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(log n). Get the first `i` elements of the set, counted from the left.\n\ntake 2 {a, b, c, d} = {a, b}\ntake 5 {a, b, c, d} = {a, b, c, d} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.take","kind":"def","line":670,"name":"Ordnode.take","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L670-L675"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux\"><span class=\"name\">Ordnode</span>.<span class=\"name\">takeAux</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"Auxiliary definition for `take`. (Can also be used in lieu of `take` if you know the\nindex is within the range of the data structure.)\n\n    takeAux {a, b, c, d} 2 = {a, b}\n    takeAux {a, b, c, d} 5 = {a, b, c, d} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.takeAux","kind":"def","line":655,"name":"Ordnode.takeAux","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L655-L668"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth\"><span class=\"name\">Ordnode</span>.<span class=\"name\">removeNth</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"O(log n). Remove the `i`th element of the set, by its index from left to right.\n\nremove_nth {a, b, c, d} 2 = {a, b, d}\nremove_nth {a, b, c, d} 5 = {a, b, c, d} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.removeNth","kind":"def","line":643,"name":"Ordnode.removeNth","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L643-L653"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth\"><span class=\"name\">Ordnode</span>.<span class=\"name\">nth</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"O(log n). Get the `i`th element of the set, by its index from left to right.\n\nnth {a, b, c, d} 2 = some c\nnth {a, b, c, d} 5 = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nth","kind":"def","line":631,"name":"Ordnode.nth","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L631-L641"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">attach'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <a href=\"./Init/Prelude.html#Subtype\">{</a> <span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#Subtype\">:</a> <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Subtype\">//</a> <span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Subtype\">}</a></span></span></div></div>","info":{"doc":"O(n). \"Attach\" the information that every element of `t` satisfies property\nP to these elements inside the set, producing a set in the subtype.\n\n    attach' (fun x ↦ x < 4) {1, 2} H = ({1, 2} : Ordnode {x // x<4}) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.attach'","kind":"def","line":624,"name":"Ordnode.attach'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L624-L629"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap\"><span class=\"name\">Ordnode</span>.<span class=\"name\">pmap</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>) → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">P</span> <span class=\"fn\">a</span></span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></span></div></div>","info":{"doc":"O(n). Map a partial function across a set. The result depends on a proof\nthat the function is defined on all members of the set.\n\n    pmap (fin.mk : ∀ n, n < 4 → fin 4) {1, 2} H = {(1 : fin 4), (2 : fin 4)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.pmap","kind":"def","line":616,"name":"Ordnode.pmap","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L616-L622"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair\"><span class=\"name\">Ordnode</span>.<span class=\"name\">copair</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> (<span class=\"fn\">α</span> <a href=\"./Init/Core.html#Sum\">⊕</a> <span class=\"fn\">β</span>)</span></div></div>","info":{"doc":"O(m + n). Build a set on the disjoint union by combining sets on the factors.\n`Or.inl a ∈ s.copair t` iff `a ∈ s`, and `Or.inr b ∈ s.copair t` iff `b ∈ t`.\n\n    copair {1, 2} {2, 3} = {inl 1, inl 2, inr 2, inr 3} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.copair","kind":"def","line":609,"name":"Ordnode.copair","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L609-L614"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod\"><span class=\"name\">Ordnode</span>.<span class=\"name\">prod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">β</span>)</span></div></div>","info":{"doc":"O(m * n). The Cartesian product of two sets: `(a, b) ∈ s.prod t` iff `a ∈ s` and `b ∈ t`.\n\nprod {1, 2} {2, 3} = {(1, 2), (1, 3), (2, 2), (2, 3)} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.prod","kind":"def","line":603,"name":"Ordnode.prod","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L603-L607"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset\"><span class=\"name\">Ordnode</span>.<span class=\"name\">powerset</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"O(2^n). Constructs the powerset of a given set, that is, the set of all subsets.\n\npowerset {1, 2, 3} = {∅, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.powerset","kind":"def","line":597,"name":"Ordnode.powerset","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L597-L601"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instDecidableRelEquivOfDecidableEq</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableRel\">DecidableRel</a> <a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv\">Equiv</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instDecidableRelEquivOfDecidableEq","kind":"instance","line":594,"name":"Ordnode.instDecidableRelEquivOfDecidableEq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L594-L595"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Equiv</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t₁ </span><span class=\"fn\">t₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Prop</a></div></div>","info":{"doc":"O(n). True if the trees have the same elements, ignoring structural differences.\n\nEquiv {1, 2, 4} {2, 1, 1, 4} = true\nEquiv {1, 2, 4} {1, 2, 3} = false ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Equiv","kind":"def","line":587,"name":"Ordnode.Equiv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L587-L592"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instToFormat</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToFormat","kind":"instance","line":584,"name":"Ordnode.instToFormat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L584-L585"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instToString</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/ToString/Basic.html#ToString\">ToString</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instToString","kind":"instance","line":581,"name":"Ordnode.instToString","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L581-L582"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">toRevList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(n). Build a list of elements in descending order from the tree.\n\ntoRevList {1, 2, 4} = [4, 2, 1]\ntoRevList {2, 1, 1, 4} = [4, 2, 1] ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toRevList","kind":"def","line":574,"name":"Ordnode.toRevList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L574-L579"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList\"><span class=\"name\">Ordnode</span>.<span class=\"name\">toList</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(n). Build a list of elements in ascending order from the tree.\n\ntoList {1, 2, 4} = [1, 2, 4]\ntoList {2, 1, 1, 4} = [1, 2, 4] ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.toList","kind":"def","line":567,"name":"Ordnode.toList","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L567-L572"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">foldr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span></div></div>","info":{"doc":"O(n). Fold a function from right to left (in decreasing order) across the tree.\n\nfoldr f {1, 2, 4} z = f 1 (f 2 (f 4 z)) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldr","kind":"def","line":560,"name":"Ordnode.foldr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L560-L565"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl\"><span class=\"name\">Ordnode</span>.<span class=\"name\">foldl</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">β</span></span></span></div></div>","info":{"doc":"O(n). Fold a function from left to right (in increasing order) across the tree.\n\nfoldl f z {1, 2, 4} = f (f (f z 1) 2) 4 ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.foldl","kind":"def","line":553,"name":"Ordnode.foldl","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L553-L558"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold\"><span class=\"name\">Ordnode</span>.<span class=\"name\">fold</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Sort</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">z</span> : <span class=\"fn\">β</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\">β</span> → <span class=\"fn\">β</span></span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">β</span></span></div></div>","info":{"doc":"O(n). Fold a function across the structure of a tree.\n\n     fold z f {1, 2, 4} = f (f z 1 z) 2 (f z 4 z)\n\nThe exact structure of function applications depends on the tree and so\nis unspecified. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.fold","kind":"def","line":543,"name":"Ordnode.fold","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L543-L551"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map\"><span class=\"name\">Ordnode</span>.<span class=\"name\">map</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">β</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">β</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">β</span></span></span></div></div>","info":{"doc":"O(n). Map a function across a tree, without changing the structure. Only valid when\nthe function is strictly monotone, i.e. `x < y → f x < f y`.\n\n     partition (fun x ↦ x + 2) {1, 2, 4} = {2, 3, 6}\n     partition (fun x : ℕ ↦ x - 2) {1, 2, 4} = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.map","kind":"def","line":534,"name":"Ordnode.map","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L534-L541"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition\"><span class=\"name\">Ordnode</span>.<span class=\"name\">partition</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(n). Split the elements of a tree into those satisfying, and not satisfying, a predicate.\n\npartition (fun x ↦ x < 3) {1, 2, 4} = ({1, 2}, {3}) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.partition","kind":"def","line":524,"name":"Ordnode.partition","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L524-L532"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter\"><span class=\"name\">Ordnode</span>.<span class=\"name\">filter</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(n). Filter the elements of a tree satisfying a predicate.\n\nfilter (fun x ↦ x < 3) {1, 2, 4} = {1, 2}\nfilter (fun x ↦ x > 5) {1, 2, 4} = ∅ ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.filter","kind":"def","line":514,"name":"Ordnode.filter","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L514-L522"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link\"><span class=\"name\">Ordnode</span>.<span class=\"name\">link</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log(m+n)). Build a tree from an element between two trees, without any\nassumption on the relative sizes.\n\n    link {1, 2} 4 {5, 6} = {1, 2, 4, 5, 6}\n    link {1, 3} 2 {5} = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.link","kind":"def","line":498,"name":"Ordnode.link","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L498-L512"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Insert an element below all the others, without any comparisons.\n(Assumes that the element is in fact below all the others).\n\n    insertMin {1, 2} 0 = {0, 1, 2}\n    insertMin {1, 2} 4 = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMin","kind":"def","line":489,"name":"Ordnode.insertMin","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L489-L496"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">insertMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"O(log n). Insert an element above all the others, without any comparisons.\n(Assumes that the element is in fact above all the others).\n\n    insertMax {1, 2} 4 = {1, 2, 4}\n    insertMax {1, 2} 0 = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.insertMax","kind":"def","line":480,"name":"Ordnode.insertMax","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L480-L487"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge\"><span class=\"name\">Ordnode</span>.<span class=\"name\">merge</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log(m + n)). Concatenate two trees that are ordered with respect to each other.\n\nmerge {1, 2} {3, 4} = {1, 2, 3, 4}\nmerge {3, 4} {1, 2} = precondition violation ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.merge","kind":"def","line":466,"name":"Ordnode.merge","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L466-L478"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue\"><span class=\"name\">Ordnode</span>.<span class=\"name\">glue</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"**Internal use only**\n\nO(log(m + n)). Concatenate two trees that are balanced and ordered with respect to each other. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.glue","kind":"def","line":452,"name":"Ordnode.glue","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L452-L464"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"O(log n). Extract and remove the maximum element from the tree, if it exists.\n\nsplit_max {1, 2, 3} = some ({1, 2}, 3)\nsplit_max ∅ = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax","kind":"def","line":444,"name":"Ordnode.splitMax","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L444-L450"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMax'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\">α</span></span></span></span></div></div>","info":{"doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the maximum element from a nonempty tree. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMax'","kind":"def","line":435,"name":"Ordnode.splitMax'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L435-L442"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span></div></div>","info":{"doc":"O(log n). Extract and remove the minimum element from the tree, if it exists.\n\nsplit_min {1, 2, 3} = some (1, {2, 3})\nsplit_min ∅ = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin","kind":"def","line":427,"name":"Ordnode.splitMin","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L427-L433"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">splitMin'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">α</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></span></span></div></div>","info":{"doc":"**Internal use only**, because it requires a balancing constraint on the inputs.\n\nO(log n). Extract and remove the minimum element from a nonempty tree. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.splitMin'","kind":"def","line":418,"name":"Ordnode.splitMin'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L418-L425"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">eraseMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Remove the maximum element from the tree, or do nothing if it is already empty.\n\neraseMax {1, 2, 3} = {1, 2}\neraseMax ∅ = ∅ ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMax","kind":"def","line":409,"name":"Ordnode.eraseMax","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L409-L416"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">eraseMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Remove the minimum element from the tree, or do nothing if it is already empty.\n\neraseMin {1, 2, 3} = {2, 3}\neraseMin ∅ = ∅ ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.eraseMin","kind":"def","line":400,"name":"Ordnode.eraseMin","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L400-L407"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMax</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Return the maximum element of the tree, if it exists.\n\nfindMax {1, 2, 3} = some 3\nfindMax ∅ = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax","kind":"def","line":392,"name":"Ordnode.findMax","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L392-L398"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMax'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Return the maximum element of the tree, or the provided default value.\n\nfindMax' 37 {1, 2, 3} = 3\nfindMax' 37 ∅ = 37 ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMax'","kind":"def","line":384,"name":"Ordnode.findMax'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L384-L390"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMin</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Return the minimum element of the tree, if it exists.\n\nfindMin {1, 2, 3} = some 1\nfindMin ∅ = none ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin","kind":"def","line":376,"name":"Ordnode.findMin","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L376-L382"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">findMin'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"O(log n). Return the minimum element of the tree, or the provided default value.\n\nfindMin' 37 {1, 2, 3} = 1\nfindMin' 37 ∅ = 37 ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.findMin'","kind":"def","line":368,"name":"Ordnode.findMin'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L368-L374"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Amem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLE\">DecidableLE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem\">Amem</a> <span class=\"fn\">x</span> <span class=\"fn\">t</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem.decidable","kind":"instance","line":365,"name":"Ordnode.Amem.decidable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L365-L366"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Amem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#LE\">LE</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"O(n). Approximate membership in the set, that is, whether some element in the\nset is equivalent to this one in the preorder. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Amem 2 {1, 2, 3} = true\n    Amem 4 {1, 2, 3} = false\n\nTo see the difference with `Emem`, we need a preorder that is not a partial order.\nFor example, suppose we compare pairs of numbers using only their first coordinate. Then:\n-- TODO: Verify below example\n    Emem (0, 1) {(0, 0), (1, 2)} = false\n    Amem (0, 1) {(0, 0), (1, 2)} = true\n    (0, 1) ∈ {(0, 0), (1, 2)} = true\n\nThe `∈` relation is equivalent to `Amem` as long as the `Ordnode` is well formed,\nand should always be used instead of `Amem`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Amem","kind":"def","line":345,"name":"Ordnode.Amem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L345-L363"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Emem</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem\">Emem</a> <span class=\"fn\">x</span> <span class=\"fn\">t</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem.decidable","kind":"instance","line":342,"name":"Ordnode.Emem.decidable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L342-L343"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Emem</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"O(n). Exact membership in the set. This is useful primarily for stating\ncorrectness properties; use `∈` for a version that actually uses the BST property\nof the tree.\n\n    Emem 2 {1, 2, 3} = true\n    Emem 4 {1, 2, 3} = false ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Emem","kind":"def","line":333,"name":"Ordnode.Emem","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L333-L340"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Any</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any\">Any</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any.decidable","kind":"instance","line":326,"name":"Ordnode.Any.decidable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L326-L331"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any\"><span class=\"name\">Ordnode</span>.<span class=\"name\">Any</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"O(n). Does any element of the map satisfy property `P`?\n\nAny (fun x ↦ x < 2) {1, 2, 3} = True\nAny (fun x ↦ x < 2) {2, 3, 5} = False ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.Any","kind":"def","line":318,"name":"Ordnode.Any","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L318-L324"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable\"><span class=\"name\">Ordnode</span>.<span class=\"name\">All</span>.<span class=\"name\">decidable</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Prelude.html#DecidablePred\">DecidablePred</a> <span class=\"fn\">P</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Decidable\">Decidable</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\">All</a> <span class=\"fn\">P</span> <span class=\"fn\">t</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All.decidable","kind":"instance","line":311,"name":"Ordnode.All.decidable","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L311-L316"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All\"><span class=\"name\">Ordnode</span>.<span class=\"name\">All</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">P</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./foundational_types.html\">Prop</a></span></div></div>","info":{"doc":"O(n). Does every element of the map satisfy property `P`?\n\nAll (fun x ↦ x < 5) {1, 2, 3} = True\nAll (fun x ↦ x < 5) {1, 2, 3, 5} = False ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.All","kind":"def","line":303,"name":"Ordnode.All","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L303-L309"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balance</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had one side change\nby at most 1. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balance","kind":"def","line":247,"name":"Ordnode.balance","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L247-L301"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balanceR</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its right\nside grow by 1, or its left side shrink by 1. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceR","kind":"def","line":213,"name":"Ordnode.balanceR","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L213-L245"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL\"><span class=\"name\">Ordnode</span>.<span class=\"name\">balanceL</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"**Internal use only**\n\nO(1). Rebalance a tree which was previously balanced but has had its left\nside grow by 1, or its right side shrink by 1. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.balanceL","kind":"def","line":179,"name":"Ordnode.balanceL","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L179-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instRepr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instRepr","kind":"instance","line":175,"name":"Ordnode.instRepr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L175-L176"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr\"><span class=\"name\">Ordnode</span>.<span class=\"name\">repr</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_2}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Init/Data/Repr.html#Repr\">Repr</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">o</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></div></div>","info":{"doc":"Basic pretty printing for `Ordnode α` that shows the structure of the tree.\n\nrepr {3, 1, 2, 4} = ((∅ 1 ∅) 2 ((∅ 3 ∅) 4 ∅)) ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.repr","kind":"def","line":163,"name":"Ordnode.repr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L163-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'\"><span class=\"name\">Ordnode</span>.<span class=\"name\">node'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"**Internal use only**\n\nO(1). Construct a node with the correct size information, without rebalancing. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node'","kind":"def","line":156,"name":"Ordnode.node'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L156-L161"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual\"><span class=\"name\">Ordnode</span>.<span class=\"name\">dual</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></span></div></div>","info":{"doc":"**Internal use only**, because it violates the BST property on the original order.\n\nO(n). The dual of a tree is a tree with its left and right sides reversed throughout.\nThe dual of a valid BST is valid under the dual order. This is convenient for exploiting\nsymmetries in the algorithms. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.dual","kind":"def","line":146,"name":"Ordnode.dual","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L146-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty\"><span class=\"name\">Ordnode</span>.<span class=\"name\">empty</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Bool\">Bool</a></span></div></div>","info":{"doc":"O(1). Is the set empty?\n\nempty ∅ = tt\nempty {1, 2, 3} = ff ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.empty","kind":"def","line":137,"name":"Ordnode.empty","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L137-L144"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size_node</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">sz</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node\">node</a> <span class=\"fn\">sz</span> <span class=\"fn\">l</span> <span class=\"fn\">x</span> <span class=\"fn\">r</span>)</span>.<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\">size</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">sz</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_node","kind":"theorem","line":133,"name":"Ordnode.size_node","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L133-L135"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size_nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil\">nil</a>.<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\">size</a></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">0</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size_nil","kind":"theorem","line":131,"name":"Ordnode.size_nil","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L131-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size\"><span class=\"name\">Ordnode</span>.<span class=\"name\">size</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span> → <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"O(1). Get the size of the set.\n\n`size {2, 1, 1, 4} = 3` ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.size","kind":"def","line":123,"name":"Ordnode.size","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L123-L129"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instSingleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#Singleton\">Singleton</a> <span class=\"fn\">α</span> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instSingleton","kind":"instance","line":120,"name":"Ordnode.instSingleton","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L120-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton\"><span class=\"name\">Ordnode</span>.<span class=\"name\">singleton</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"O(1). Construct a singleton set containing value `a`.\n\nsingleton 3 = {3} ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.singleton","kind":"def","line":111,"name":"Ordnode.singleton","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L111-L116"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio\"><span class=\"name\">Ordnode</span>.<span class=\"name\">ratio</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>","info":{"doc":"**Internal use only**\n\nThe ratio between an outer and inner sibling of the\nheavier subtree in an unbalanced setting. It determines\nwhether a double or single rotation should be performed\nto restore balance. It is corresponds with the inverse\nof `α` in Adam's article. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.ratio","kind":"def","line":100,"name":"Ordnode.ratio","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L100-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta\"><span class=\"name\">Ordnode</span>.<span class=\"name\">delta</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a></div></div>","info":{"doc":"**Internal use only**\n\nThe maximal relative difference between the sizes of\ntwo trees, it corresponds with the `w` in Adams' paper.\n\nAccording to the Haskell comment, only `(delta, ratio)` settings\nof `(3, 2)` and `(4, 2)` will work, and the proofs in\n`Ordset.lean` assume `delta := 3` and `ratio := 2`. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.delta","kind":"def","line":88,"name":"Ordnode.delta","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L88-L98"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instInhabited</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instInhabited","kind":"instance","line":85,"name":"Ordnode.instInhabited","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L85-L86"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection\"><span class=\"name\">Ordnode</span>.<span class=\"name\">instEmptyCollection</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Core.html#EmptyCollection\">EmptyCollection</a> <span class=\"fn\">(<a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.instEmptyCollection","kind":"instance","line":82,"name":"Ordnode.instEmptyCollection","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L82-L83"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node\"><span class=\"name\">Ordnode</span>.<span class=\"name\">node</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">size</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">l</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">r</span> : <span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.node","kind":"ctor","line":75,"name":"Ordnode.node","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L75-L75"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil\"><span class=\"name\">Ordnode</span>.<span class=\"name\">nil</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\">Ordnode</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode.nil","kind":"ctor","line":74,"name":"Ordnode.nil","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L74-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode\"><span class=\"name\">Ordnode</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a> u</div></div>","info":{"doc":"An `Ordnode α` is a finite set of values, represented as a tree.\nThe operations on this type maintain that the tree is balanced\nand correctly stores subtree sizes at each level. ","docLink":"./Mathlib/Data/Ordmap/Ordnode.html#Ordnode","kind":"inductive","line":70,"name":"Ordnode","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Data/Ordmap/Ordnode.lean#L70-L75"}}],"imports":["Init","Mathlib.Order.Compare","Mathlib.Data.Nat.PSub","Mathlib.Data.Option.Basic","Batteries.Data.List.Basic"],"instances":[{"className":"EmptyCollection","name":"Ordnode.instEmptyCollection","typeNames":["Ordnode"]},{"className":"Inhabited","name":"Ordnode.instInhabited","typeNames":["Ordnode"]},{"className":"Singleton","name":"Ordnode.instSingleton","typeNames":["Ordnode"]},{"className":"Repr","name":"Ordnode.instRepr","typeNames":["Ordnode"]},{"className":"Decidable","name":"Ordnode.All.decidable","typeNames":["Ordnode.All"]},{"className":"Decidable","name":"Ordnode.Any.decidable","typeNames":["Ordnode.Any"]},{"className":"Decidable","name":"Ordnode.Emem.decidable","typeNames":["Ordnode.Emem"]},{"className":"Decidable","name":"Ordnode.Amem.decidable","typeNames":["Ordnode.Amem"]},{"className":"ToString","name":"Ordnode.instToString","typeNames":["Ordnode"]},{"className":"Std.ToFormat","name":"Ordnode.instToFormat","typeNames":["Ordnode"]},{"className":"Decidable","name":"Ordnode.instDecidableRelEquivOfDecidableEq","typeNames":["Ordnode.Equiv"]},{"className":"Membership","name":"Ordnode.instMembership","typeNames":["Ordnode"]},{"className":"Decidable","name":"Ordnode.mem.decidable","typeNames":["Membership.mem"]},{"className":"Insert","name":"Ordnode.instInsert","typeNames":["Ordnode"]}],"name":"Mathlib.Data.Ordmap.Ordnode"}