{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.¬´termElementwise_of%_¬ª\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">¬´termElementwise_of%_¬ª</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`elementwise_of% h`, where `h` is a proof of an equation `f = g` between\nmorphisms `X ‚ü∂ Y` in a concrete category (possibly after a `‚àÄ` binder),\nproduces a proof of equation `‚àÄ (x : X), f x = g x`, but with compositions fully\nright associated and identities removed.\n\nA typical example is using `elementwise_of%` to dynamically generate rewrite lemmas:\n```lean\nexample (M N K : MonCat) (f : M ‚ü∂ N) (g : N ‚ü∂ K) (h : M ‚ü∂ K) (w : f ‚â´ g = h) (m : M) :\n    g (f m) = h m := by rw [elementwise_of% w]\n```\nIn this case, `elementwise_of% w` generates the lemma `‚àÄ (x : M), f (g x) = h x`.\n\nLike the `@[elementwise]` attribute, `elementwise_of%` inserts a `HasForget`\ninstance argument if it can't synthesize a relevant `HasForget` instance.\n(Technical note: The forgetful functor's universe variable is instantiated with a\nfresh level metavariable in this case.)\n\nOne difference between `elementwise_of%` and `@[elementwise]` is that `@[elementwise]` by\ndefault applies `simp` to both sides of the generated lemma to get something that is in simp\nnormal form. `elementwise_of%` does not do this.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.¬´termElementwise_of%_¬ª","kind":"def","line":234,"name":"Tactic.Elementwise.¬´termElementwise_of%_¬ª","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L234-L259"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwise\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwise</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `elementwise` attribute can be added to a lemma proving an equation of morphisms, and it\ncreates a new lemma for a `HasForget` giving an equation with those morphisms applied\nto some value.\n\nSyntax examples:\n- `@[elementwise]`\n- `@[elementwise nosimp]` to not use `simp` on both sides of the generated lemma\n- `@[elementwise (attr := simp)]` to apply the `simp` attribute to both the generated lemma and\n  the original lemma.\n\nExample application of `elementwise`:\n\n```lean\n@[elementwise]\nlemma some_lemma {C : Type*} [Category* C]\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : X ‚ü∂ Z) (w : ...) : f ‚â´ g = h := ...\n```\n\nproduces\n\n```lean\nlemma some_lemma_apply {C : Type*} [Category* C]\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : X ‚ü∂ Z) (w : ...)\n    [HasForget C] (x : X) : g (f x) = h x := ...\n```\n\nHere `X` is being coerced to a type via `CategoryTheory.HasForget.hasCoeToSort` and\n`f`, `g`, and `h` are being coerced to functions via `CategoryTheory.HasForget.hasCoeToFun`.\nFurther, we simplify the type using `CategoryTheory.coe_id : ((ùüô X) : X ‚Üí X) x = x` and\n`CategoryTheory.coe_comp : (f ‚â´ g) x = g (f x)`,\nreplacing morphism composition with function composition.\n\nThe `[HasForget C]` argument will be omitted if it is possible to synthesize an instance.\n\nThe name of the produced lemma can be specified with `@[elementwise other_lemma_name]`.\nIf `simp` is added first, the generated lemma will also have the `simp` attribute.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwise","kind":"def","line":171,"name":"Tactic.Elementwise.elementwise","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L171-L209"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwiseExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">src</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">simpSides</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a> <a href=\"./Init/Prelude.html#Prod\">√ó</a> <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>)</span>)</span></div></div>","info":{"doc":"Given an equation `f = g` between morphisms `X ‚ü∂ Y` in a category `C`\n(possibly after a `‚àÄ` binder), produce the equation `‚àÄ (x : X), f x = g x` or\n`‚àÄ [HasForget C] (x : X), f x = g x` as needed (after the `‚àÄ` binder), but\nwith compositions fully right associated and identities removed.\n\nReturns the proof of the new theorem along with (optionally) a new level metavariable\nfor the first universe parameter to `HasForget`.\n\nThe `simpSides` option controls whether to simplify both sides of the equality, for simpNF\npurposes.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseExpr","kind":"def","line":76,"name":"Tactic.Elementwise.elementwiseExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L76-L156"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseThms\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">elementwiseThms</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"List of simp lemmas to apply to the elementwise theorem. ","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.elementwiseThms","kind":"def","line":60,"name":"Tactic.Elementwise.elementwiseThms","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L60-L74"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.hom_elementwise\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">hom_elementwise</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">CategoryTheory.Category.{v_1, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.HasForget\">CategoryTheory.HasForget</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">‚ü∂</a> <span class=\"fn\">Y</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget\">CategoryTheory.forget</a> <span class=\"fn\">C</span>)</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">X</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\">f</span> <span class=\"fn\">x</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><span class=\"fn\">g</span> <span class=\"fn\">x</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.hom_elementwise","kind":"theorem","line":55,"name":"Tactic.Elementwise.hom_elementwise","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L55-L56"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forget_hom_Type\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">forget_hom_Type</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Œ± </span><span class=\"fn\">Œ≤</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\">Œ±</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">‚ü∂</a> <span class=\"fn\">Œ≤</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">‚áë<span class=\"fn\">f</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">f</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forget_hom_Type","kind":"theorem","line":53,"name":"Tactic.Elementwise.forget_hom_Type","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L53-L53"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forall_congr_forget_Type\"><span class=\"name\">Tactic</span>.<span class=\"name\">Elementwise</span>.<span class=\"name\">forall_congr_forget_Type</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Œ±</span> : <a href=\"./foundational_types.html\">Type</a> u)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><span class=\"fn\">Œ±</span> ‚Üí <a href=\"./foundational_types.html\">Prop</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(‚àÄ (<span class=\"fn\">x</span> : <span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<a href=\"./Mathlib/CategoryTheory/ConcreteCategory/Basic.html#CategoryTheory.forget\">CategoryTheory.forget</a> <a href=\"./foundational_types.html\">(Type</a> u))</span>.<a href=\"./Mathlib/CategoryTheory/Functor/Basic.html#CategoryTheory.Functor.obj\">obj</a></span> <span class=\"fn\">Œ±</span></span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span>)</span> <a href=\"./Init/Core.html#Iff\">‚Üî</a> <span class=\"fn\">‚àÄ (<span class=\"fn\">x</span> : <span class=\"fn\">Œ±</span>), <span class=\"fn\"><span class=\"fn\">p</span> <span class=\"fn\">x</span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/CategoryTheory/Elementwise.html#Tactic.Elementwise.forall_congr_forget_Type","kind":"theorem","line":48,"name":"Tactic.Elementwise.forall_congr_forget_Type","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Elementwise.lean#L48-L49"}}],"imports":["Init","Mathlib.CategoryTheory.ConcreteCategory.Basic","Mathlib.Util.AddRelatedDecl","Batteries.Tactic.Lint"],"instances":[],"name":"Mathlib.Tactic.CategoryTheory.Elementwise"}