{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.«termTo_app_of%_»\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">«termTo_app_of%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Given an equation `t` of the form `η = θ` between 2-morphisms `f ⟶ g` with `f g : C ⟶ D` in the\nbicategory `Cat` (possibly after a `∀` binder), `to_app_of% t` produces the equation\n`∀ (X : C), η.app X = θ.app X` (where `X` is an object in the domain of `f` and `g`), and simplifies\nit suitably using basic lemmas about `NatTrans.app`.\n","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.«termTo_app_of%_»","kind":"def","line":140,"name":"CategoryTheory.«termTo_app_of%_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/ToApp.lean#L140-L147"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.to_app\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">to_app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Adding `@[to_app]` to a lemma named `F` of shape `∀ .., η = θ`, where `η θ : f ⟶ g` are 2-morphisms\nin some bicategory, create a new lemma named `F_app`. This lemma is obtained by first specializing\nthe bicategory in which the equality is taking place to `Cat`, then applying `NatTrans.congr_app`\nto obtain a proof of `∀ ... (X : Cat), η.app X = θ.app X`, and finally simplifying the conclusion\nusing some basic lemmas in the bicategory `Cat`:\n`Cat.whiskerLeft_app`, `Cat.whiskerRight_app`, `Cat.id_app`, `Cat.comp_app` and `Cat.eqToHom_app`\n\nSo, for example, if the conclusion of `F` is `f ◁ η = θ` then the conclusion of `F_app` will be\n`η.app (f.obj X) = θ.app X`.\n\nThis is useful for automatically generating lemmas that can be applied to expressions of 1-morphisms\nin `Cat` which contain components of 2-morphisms.\n\nNote that if you want both the lemma and the new lemma to be `simp` lemmas, you should tag the lemma\n`@[to_app (attr := simp)]`. The variant `@[simp, to_app]` on a lemma `F` will tag `F` with\n`@[simp]`, but not `F_app` (this is sometimes useful).\n","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.to_app","kind":"def","line":102,"name":"CategoryTheory.to_app","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/ToApp.lean#L102-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toAppExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toAppExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Given morphisms `f g : C ⟶ D` in the bicategory `Cat`, and an equation `η = θ` between 2-morphisms\n(possibly after a `∀` binder), produce the equation `∀ (X : C), f.app X = g.app X`, and simplify\nit using basic lemmas about `NatTrans.app`. ","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toAppExpr","kind":"def","line":95,"name":"CategoryTheory.toAppExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/ToApp.lean#L95-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toCatExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">toCatExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Given a term of type `∀ ..., η = θ`, where `η θ : f ⟶ g` are 2-morphisms in some bicategory\n`B`, which is bound by the `∀` binder, get the corresponding equation in the bicategory `Cat`.\n\nIt is important here that the levels in the term are level metavariables, as otherwise these will\nnot be reassignable to the corresponding levels of `Cat`. ","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.toCatExpr","kind":"def","line":48,"name":"CategoryTheory.toCatExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/ToApp.lean#L48-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.catAppSimp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">catAppSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Simplify an expression in `Cat` using basic properties of `NatTrans.app`. ","docLink":"./Mathlib/Tactic/CategoryTheory/ToApp.html#CategoryTheory.catAppSimp","kind":"def","line":38,"name":"CategoryTheory.catAppSimp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/ToApp.lean#L38-L46"}}],"imports":["Init","Mathlib.CategoryTheory.Category.Cat","Mathlib.CategoryTheory.Category.Cat","Mathlib.Util.AddRelatedDecl"],"instances":[],"name":"Mathlib.Tactic.CategoryTheory.ToApp"}