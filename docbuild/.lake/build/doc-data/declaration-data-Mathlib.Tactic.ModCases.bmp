{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">«tacticMod_cases_:_%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"* The tactic `mod_cases h : e % 3` will perform a case disjunction on `e`.\n  If `e : ℤ`, then it will yield subgoals containing the assumptions\n  `h : e ≡ 0 [ZMOD 3]`, `h : e ≡ 1 [ZMOD 3]`, `h : e ≡ 2 [ZMOD 3]`\n  respectively. If `e : ℕ` instead, then it works similarly, except with\n  `[MOD 3]` instead of `[ZMOD 3]`.\n* In general, `mod_cases h : e % n` works\n  when `n` is a positive numeral and `e` is an expression of type `ℕ` or `ℤ`.\n* If `h` is omitted as in `mod_cases e % n`, it will be default-named `H`.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»","kind":"def","line":175,"name":"Mathlib.Tactic.ModCases.«tacticMod_cases_:_%_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L175-L185"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.modCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">modCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Nat case of `mod_cases h : e % n`.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.modCases","kind":"def","line":156,"name":"Mathlib.Tactic.ModCases.NatMod.modCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L156-L171"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.proveOnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">proveOnModCases</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$b»</span> <span class=\"fn\">«$p»</span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>","info":{"doc":"Proves an expression of the form `OnModCases n a b p` where `n` and `b` are raw nat literals\nand `b ≤ n`. Returns the list of subgoals `?gi : a ≡ i [MOD n] → p`.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.proveOnModCases","kind":"opaque","line":140,"name":"Mathlib.Tactic.ModCases.NatMod.proveOnModCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L140-L154"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_succ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">onModCases_succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Mathlib/Data/Nat/ModEq.html#Nat.ModEq\">≡</a> <span class=\"fn\">b</span> <a href=\"./Mathlib/Data/Nat/ModEq.html#Nat.ModEq\">[MOD</a> <span class=\"fn\">n</span><a href=\"./Mathlib/Data/Nat/ModEq.html#Nat.ModEq\">]</a> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">b</span>.<a href=\"./Init/Prelude.html#Nat.add\">add</a></span> <span class=\"fn\">1</span>)</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span> <span class=\"fn\">p</span></span></div></div>","info":{"doc":"The successor case decomposes `∃ m, b ≤ m < n ∧ a ≡ m (mod n)` into\n`a ≡ b (mod n) ∨ ∃ m, b+1 ≤ m < n ∧ a ≡ m (mod n)`,\nand the `a ≡ b (mod n) → p` case becomes a subgoal.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_succ","kind":"def","line":130,"name":"Mathlib.Tactic.ModCases.NatMod.onModCases_succ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L130-L138"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_stop\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">onModCases_stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">p</span></span></div></div>","info":{"doc":"The end point is that once we have reduced to `∃ m, n ≤ m < n ∧ a ≡ m (mod n)`\nthere are no more cases to consider.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_stop","kind":"def","line":123,"name":"Mathlib.Tactic.ModCases.NatMod.onModCases_stop","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L123-L128"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_start\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">onModCases_start</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hn</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.ble\">Nat.ble</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">0</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>","info":{"doc":"The first theorem we apply says that `∃ m, 0 ≤ m < n ∧ a ≡ m (mod n)`.\nThe actual mathematical content of the proof is here.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.onModCases_start","kind":"def","line":111,"name":"Mathlib.Tactic.ModCases.NatMod.onModCases_start","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L111-L120"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">NatMod</span>.<span class=\"name\">OnModCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">a </span><span class=\"fn\">lb</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Sort</a> u_1</div></div>","info":{"doc":"`OnModCases n a lb p` represents a partial proof by cases that\nthere exists `0 ≤ m < n` such that `a ≡ m (mod n)`.\nIt asserts that if `∃ m, lb ≤ m < n ∧ a ≡ m (mod n)` holds, then `p`\n(where `p` is the current goal).\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.NatMod.OnModCases","kind":"def","line":102,"name":"Mathlib.Tactic.ModCases.NatMod.OnModCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L102-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.modCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">modCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <a href=\"./Init/Prelude.html#Lean.TSyntax\">Lean.TSyntax</a> <span class=\"fn\">`Lean.binderIdent</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Tactic/Basic.html#Lean.Elab.Tactic.TacticM\">Lean.Elab.Tactic.TacticM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Int case of `mod_cases h : e % n`.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.modCases","kind":"def","line":81,"name":"Mathlib.Tactic.ModCases.IntMod.modCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L81-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.proveOnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">proveOnModCases</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Sort</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$a»</span> <span class=\"fn\">«$b»</span> <span class=\"fn\">«$p»</span></span>)</span> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#List\">List</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>","info":{"doc":"Proves an expression of the form `OnModCases n a b p` where `n` and `b` are raw nat literals\nand `b ≤ n`. Returns the list of subgoals `?gi : a ≡ i [ZMOD n] → p`.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.proveOnModCases","kind":"opaque","line":64,"name":"Mathlib.Tactic.ModCases.IntMod.proveOnModCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L64-L79"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_succ\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">onModCases_succ</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\"><span class=\"fn\">a</span> <a href=\"./Mathlib/Data/Int/ModEq.html#Int.ModEq\">≡</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat.ofNat\">OfNat.ofNat</a> <span class=\"fn\">b</span></span> <a href=\"./Mathlib/Data/Int/ModEq.html#Int.ModEq\">[ZMOD</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#OfNat.ofNat\">OfNat.ofNat</a> <span class=\"fn\">n</span></span><a href=\"./Mathlib/Data/Int/ModEq.html#Int.ModEq\">]</a> → <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">b</span>.<a href=\"./Init/Prelude.html#Nat.add\">add</a></span> <span class=\"fn\">1</span>)</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span> <span class=\"fn\">p</span></span></div></div>","info":{"doc":"The successor case decomposes `∃ z, b ≤ z < n ∧ a ≡ z (mod n)` into\n`a ≡ b (mod n) ∨ ∃ z, b+1 ≤ z < n ∧ a ≡ z (mod n)`,\nand the `a ≡ b (mod n) → p` case becomes a subgoal.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_succ","kind":"def","line":54,"name":"Mathlib.Tactic.ModCases.IntMod.onModCases_succ","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L54-L62"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_stop\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">onModCases_stop</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">n</span> <span class=\"fn\">p</span></span></div></div>","info":{"doc":"The end point is that once we have reduced to `∃ z, n ≤ z < n ∧ a ≡ z (mod n)`\nthere are no more cases to consider.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_stop","kind":"def","line":47,"name":"Mathlib.Tactic.ModCases.IntMod.onModCases_stop","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L47-L52"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_start\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">onModCases_start</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hn</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat.ble\">Nat.ble</a> <span class=\"fn\">1</span> <span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#Bool.true\">true</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">H</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\">OnModCases</a> <span class=\"fn\">n</span> <span class=\"fn\">a</span> <span class=\"fn\">0</span> <span class=\"fn\">p</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">p</span></div></div>","info":{"doc":"The first theorem we apply says that `∃ z, 0 ≤ z < n ∧ a ≡ z (mod n)`.\nThe actual mathematical content of the proof is here.\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.onModCases_start","kind":"def","line":34,"name":"Mathlib.Tactic.ModCases.IntMod.onModCases_start","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L34-L45"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ModCases</span>.<span class=\"name\">IntMod</span>.<span class=\"name\">OnModCases</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">lb</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./foundational_types.html\">Sort</a> u_1)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Sort</a> u_1</div></div>","info":{"doc":"`OnModCases n a lb p` represents a partial proof by cases that\nthere exists `0 ≤ z < n` such that `a ≡ z (mod n)`.\nIt asserts that if `∃ z, lb ≤ z < n ∧ a ≡ z (mod n)` holds, then `p`\n(where `p` is the current goal).\n","docLink":"./Mathlib/Tactic/ModCases.html#Mathlib.Tactic.ModCases.IntMod.OnModCases","kind":"def","line":25,"name":"Mathlib.Tactic.ModCases.IntMod.OnModCases","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ModCases.lean#L25-L32"}}],"imports":["Init","Mathlib.Data.Int.ModEq","Mathlib.Tactic.HaveI"],"instances":[],"name":"Mathlib.Tactic.ModCases"}