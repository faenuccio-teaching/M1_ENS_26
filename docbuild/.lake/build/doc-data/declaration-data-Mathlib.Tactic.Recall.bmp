{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Recall.html#Mathlib.Tactic.Recall.recall\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Recall</span>.<span class=\"name\">recall</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The `recall` command redeclares a previous definition for illustrative purposes.\nThis can be useful for files that give an expository account of some theory in Lean.\n\nThe syntax of the command mirrors `def`, so all the usual bells and whistles work.\n```\nrecall List.cons_append (a : α) (as bs : List α) : (a :: as) ++ bs = a :: (as ++ bs) := rfl\n```\nAlso, one can leave out the body.\n```\nrecall Nat.add_comm (n m : Nat) : n + m = m + n\n```\n\nThe command verifies that the new definition type-checks and that the type and value\nprovided are definitionally equal to the original declaration. However, this does not\ncapture some details (like binders), so the following works without error.\n```\nrecall Nat.add_comm {n m : Nat} : n + m = m + n\n```\n","docLink":"./Mathlib/Tactic/Recall.html#Mathlib.Tactic.Recall.recall","kind":"def","line":20,"name":"Mathlib.Tactic.Recall.recall","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Recall.lean#L20-L40"}}],"imports":["Init","Mathlib.Init","Lean.Elab.Command","Lean.Elab.DeclUtil"],"instances":[],"name":"Mathlib.Tactic.Recall"}