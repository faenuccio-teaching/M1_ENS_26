{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto!\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">itauto!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A decision procedure for intuitionistic propositional logic. Unlike `finish` and `tauto!` this\ntactic never uses the law of excluded middle (without the `!` option), and the proof search is\ntailored for this use case. (`itauto!` will work as a classical SAT solver, but the algorithm is\nnot very good in this situation.)\n\n```lean\nexample (p : Prop) : ¬ (p ↔ ¬ p) := by itauto\n```\n\n`itauto [a, b]` will additionally attempt case analysis on `a` and `b` assuming that it can derive\n`Decidable a` and `Decidable b`. `itauto *` will case on all decidable propositions that it can\nfind among the atomic propositions, and `itauto! *` will case on all propositional atoms.\n*Warning:* This can blow up the proof search, so it should be used sparingly.\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto!","kind":"def","line":724,"name":"Mathlib.Tactic.ITauto.itauto!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L724-L724"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">itauto</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"A decision procedure for intuitionistic propositional logic. Unlike `finish` and `tauto!` this\ntactic never uses the law of excluded middle (without the `!` option), and the proof search is\ntailored for this use case. (`itauto!` will work as a classical SAT solver, but the algorithm is\nnot very good in this situation.)\n\n```lean\nexample (p : Prop) : ¬ (p ↔ ¬ p) := by itauto\n```\n\n`itauto [a, b]` will additionally attempt case analysis on `a` and `b` assuming that it can derive\n`Decidable a` and `Decidable b`. `itauto *` will case on all decidable propositions that it can\nfind among the atomic propositions, and `itauto! *` will case on all propositional atoms.\n*Warning:* This can blow up the proof search, so it should be used sparingly.\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itauto","kind":"def","line":701,"name":"Mathlib.Tactic.ITauto.itauto","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L701-L715"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itautoCore\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">itautoCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">useDec </span><span class=\"fn\">useClassical</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">extraDec</span> : <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"A decision procedure for intuitionistic propositional logic.\n\n* `useDec` will add `a ∨ ¬ a` to the context for every decidable atomic proposition `a`.\n* `useClassical` will allow `a ∨ ¬ a` to be added even if the proposition is not decidable,\n  using classical logic.\n* `extraDec` will add `a ∨ ¬ a` to the context for specified (not necessarily atomic)\n  propositions `a`.\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.itautoCore","kind":"def","line":637,"name":"Mathlib.Tactic.ITauto.itautoCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L637-L697"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.applyProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">applyProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">g</span> : <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <span class=\"fn\"><a href=\"./Lean/Data/NameMap/Basic.html#Lean.NameMap\">Lean.NameMap</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Once we have a proof object, we have to apply it to the goal. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.applyProof","kind":"opaque","line":496,"name":"Mathlib.Tactic.ITauto.applyProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L496-L635"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.reify\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">reify</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Prop</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Util/AtomM.html#Mathlib.Tactic.AtomM\">AtomM</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"Reify an `Expr` into a `IProp`, allocating anything non-propositional as an atom in the\n`AtomM` state. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.reify","kind":"opaque","line":479,"name":"Mathlib.Tactic.ITauto.reify","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L479-L494"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.prove\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">prove</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></div></div>","info":{"doc":"The main prover. This receives a context of proven or assumed lemmas and a target proposition,\nand returns a proof or `none` (with state for the fresh variable generator).\nThe intuitionistic logic rules are separated into three groups:\n\n* level 1: No splitting, validity preserving: apply whenever you can.\n  Left rules in `Context.add`, right rules in `prove`\n* level 2: Splitting rules, validity preserving: apply after level 1 rules. Done in `prove`\n* level 3: Splitting rules, not validity preserving: apply only if nothing else applies.\n  Done in `search`\n\nThe level 1 rules on the right of the turnstile are `Γ ⊢ ⊤` and `Γ ⊢ A → B`, these are easy to\nhandle. The rule `Γ ⊢ A ∧ B` is a level 2 rule, also handled here. If none of these apply, we try\nthe level 2 rule `A ∨ B ⊢ C` by searching the context and splitting all ors we find. Finally, if\nwe don't make any more progress, we go to the search phase.\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.prove","kind":"opaque","line":437,"name":"Mathlib.Tactic.ITauto.prove","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L437-L473"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.search\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">search</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></div></div>","info":{"doc":"The search phase, which deals with the level 3 rules, which are rules that are not validity\npreserving and so require proof search. One obvious one is the or-introduction rule: we prove\n`A ∨ B` by proving `A` or `B`, and we might have to try one and backtrack.\n\nThere are two rules dealing with implication in this category: `p, p → C ⊢ B` where `p` is an\natom (which is safe if we can find it but often requires the right search to expose the `p`\nassumption), and `(A₁ → A₂) → C ⊢ B`. We decompose the double implication into two subgoals: one to\nprove `A₁ → A₂`, which can be written `A₂ → C, A₁ ⊢ A₂` (where we used `A₁` to simplify\n`(A₁ → A₂) → C`), and one to use the consequent, `C ⊢ B`. The search here is that there are\npotentially many implications to split like this, and we have to try all of them if we want to be\ncomplete. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.search","kind":"opaque","line":403,"name":"Mathlib.Tactic.ITauto.search","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L403-L435"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.whenOk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">whenOk</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span></span></span></div></div>","info":{"doc":"Skip the continuation and return a failed proof if the Boolean is false. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.whenOk","kind":"def","line":396,"name":"Mathlib.Tactic.ITauto.whenOk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L396-L399"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.isOk\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">isOk</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">(<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>) <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> (<a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span></div></div>","info":{"doc":"Convert a value-with-success to an optional value. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.isOk","kind":"def","line":391,"name":"Mathlib.Tactic.ITauto.isOk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L391-L394"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.mapProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">mapProof</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>","info":{"doc":"Map a function over the proof (regardless of whether the proof is successful or not). ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.mapProof","kind":"def","line":387,"name":"Mathlib.Tactic.ITauto.mapProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L387-L389"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.withAdd\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span>.<span class=\"name\">withAdd</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">A</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">B</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> (<a href=\"./Init/Prelude.html#Bool\">Bool</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></div></div>","info":{"doc":"Add `A` to the context `Γ` with proof `p`. This version of `Context.add` takes a continuation\nand a target proposition `B`, so that in the case that `⊥` is found we can skip the continuation\nand just prove `B` outright. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.withAdd","kind":"def","line":378,"name":"Mathlib.Tactic.ITauto.Context.withAdd","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L378-L385"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.add\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span>.<span class=\"name\">add</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Except\">Except</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a></span></span></span></span></div></div>","info":{"doc":"Insert a proposition and its proof into the context, as in `have : A := p`. This will eagerly\napply all level 1 rules on the spot, which are rules that don't split the goal and are validity\npreserving: specifically, we drop `⊤` and `A → ⊤` hypotheses, close the goal if we find a `⊥`\nhypothesis, split all conjunctions, and also simplify `⊥ → A` (drop), `⊤ → A` (simplify to `A`),\n`A ∧ B → C` (curry to `A → B → C`) and `A ∨ B → C` (rewrite to `(A → C) ∧ (B → C)` and split). ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.add","kind":"opaque","line":355,"name":"Mathlib.Tactic.ITauto.Context.add","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L355-L376"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatContext\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToFormatContext</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatContext","kind":"instance","line":353,"name":"Mathlib.Tactic.ITauto.instToFormatContext","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L353-L353"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.format\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span>.<span class=\"name\">format</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">Γ</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\">Context</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></div></div>","info":{"doc":"Debug printer for the context. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context.format","kind":"def","line":349,"name":"Mathlib.Tactic.ITauto.Context.format","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L349-L351"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Context</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"The context during proof search is a map from propositions to proof values. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Context","kind":"def","line":346,"name":"Mathlib.Tactic.ITauto.Context","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L346-L347"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.freshName\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">freshName</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Control/State.html#StateM\">StateM</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a> <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a></span></div></div>","info":{"doc":"Get a new name in the pattern `h0, h1, h2, ...` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.freshName","kind":"def","line":343,"name":"Mathlib.Tactic.ITauto.freshName","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L343-L344"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">app</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>","info":{"doc":"A variant on `Proof.app'` that performs opportunistic simplification.\n(This doesn't do full normalization because we don't want the proof size to blow up.) ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app","kind":"def","line":274,"name":"Mathlib.Tactic.ITauto.Proof.app","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L274-L282"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orElim</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></span></span></div></div>","info":{"doc":"A variant on `Proof.orElim'` that performs opportunistic simplification. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim","kind":"def","line":269,"name":"Mathlib.Tactic.ITauto.Proof.orElim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L269-L272"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">exfalso</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></span></div></div>","info":{"doc":"A variant on `Proof.exfalso'` that performs opportunistic simplification. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso","kind":"def","line":264,"name":"Mathlib.Tactic.ITauto.Proof.exfalso","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L264-L267"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToFormatProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatProof","kind":"instance","line":262,"name":"Mathlib.Tactic.ITauto.instToFormatProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L262-L262"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.format\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">format</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></div></div>","info":{"doc":"Debugging printer for proof objects. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.format","kind":"def","line":239,"name":"Mathlib.Tactic.ITauto.Proof.format","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L239-L260"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instInhabitedProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedProof","kind":"instance","line":237,"name":"Mathlib.Tactic.ITauto.instInhabitedProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L237-L237"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprProof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprProof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprProof","kind":"instance","line":235,"name":"Mathlib.Tactic.ITauto.instToExprProof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprProof.toExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprProof</span>.<span class=\"name\">toExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprProof.toExpr","kind":"def","line":235,"name":"Mathlib.Tactic.ITauto.instToExprProof.toExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L235-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.impImpSimp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">impImpSimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"The variable `x` here names the variable that will be used in the elaborated proof.\n* `(p: ((x:A) → B) → C) ⊢ B → C`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.impImpSimp","kind":"ctor","line":231,"name":"Mathlib.Tactic.ITauto.Proof.impImpSimp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L231-L234"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.em\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">em</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">classical</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"* `classical = false`: `(p: Decidable A) ⊢ A ∨ ¬A`\n* `classical = true`: `(p: Prop) ⊢ p ∨ ¬p`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.em","kind":"ctor","line":226,"name":"Mathlib.Tactic.ITauto.Proof.em","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L226-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.decidableElim\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">decidableElim</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">classical</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₁ </span><span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₂ </span><span class=\"fn\">p₃</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p₁: Decidable A) (p₂: (x: A) ⊢ C) (p₃: (x: ¬ A) ⊢ C) ⊢ C` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.decidableElim","kind":"ctor","line":224,"name":"Mathlib.Tactic.ITauto.Proof.decidableElim","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L224-L225"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orElim'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₁</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₂ </span><span class=\"fn\">p₃</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p₁: A ∨ B) (p₂: (x: A) ⊢ C) (p₃: (x: B) ⊢ C) ⊢ C` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orElim'","kind":"ctor","line":222,"name":"Mathlib.Tactic.ITauto.Proof.orElim'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L222-L223"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orInR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p: B) ⊢ A ∨ B` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInR","kind":"ctor","line":220,"name":"Mathlib.Tactic.ITauto.Proof.orInR","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L220-L221"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInL\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orInL</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p: A) ⊢ A ∨ B` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orInL","kind":"ctor","line":218,"name":"Mathlib.Tactic.ITauto.Proof.orInL","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L218-L219"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpR\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orImpR</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p: A ∨ B → C) ⊢ B → C` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpR","kind":"ctor","line":216,"name":"Mathlib.Tactic.ITauto.Proof.orImpR","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L216-L217"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpL\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">orImpL</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p: A ∨ B → C) ⊢ A → C` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.orImpL","kind":"ctor","line":214,"name":"Mathlib.Tactic.ITauto.Proof.orImpL","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L214-L215"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">app'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></span></div></div>","info":{"doc":"`(p: A → B) (q: A) ⊢ B` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.app'","kind":"ctor","line":212,"name":"Mathlib.Tactic.ITauto.Proof.app'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L212-L213"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry₂\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">curry₂</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"This is a partial application of curry.\n* `ak = .and`: `(p: A ∧ B → C) (q : A) ⊢ B → C`\n* `ak = .iff`: `(p: (A ↔ B) → C) (q: A → B) ⊢ (B → A) → C`\n* `ak = .eq`: `(p: (A ↔ B) → C) (q: A → B) ⊢ (B → A) → C`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry₂","kind":"ctor","line":206,"name":"Mathlib.Tactic.ITauto.Proof.curry₂","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L206-L211"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">curry</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"* `ak = .and`: `(p: A ∧ B → C) ⊢ A → B → C`\n* `ak = .iff`: `(p: (A ↔ B) → C) ⊢ (A → B) → (B → A) → C`\n* `ak = .eq`: `(p: (A = B) → C) ⊢ (A → B) → (B → A) → C`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.curry","kind":"ctor","line":200,"name":"Mathlib.Tactic.ITauto.Proof.curry","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L200-L205"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andIntro\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">andIntro</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p₁ </span><span class=\"fn\">p₂</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"* `ak = .and`: `(p₁: A) (p₂: B) ⊢ A ∧ B`\n* `ak = .iff`: `(p₁: A → B) (p₁: B → A) ⊢ A ↔ B`\n* `ak = .eq`: `(p₁: A → B) (p₁: B → A) ⊢ A = B`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andIntro","kind":"ctor","line":194,"name":"Mathlib.Tactic.ITauto.Proof.andIntro","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L194-L199"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andRight\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">andRight</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"* `ak = .and`: `(p: A ∧ B) ⊢ B`\n* `ak = .iff`: `(p: A ↔ B) ⊢ B → A`\n* `ak = .eq`: `(p: A = B) ⊢ B → A`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andRight","kind":"ctor","line":188,"name":"Mathlib.Tactic.ITauto.Proof.andRight","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L188-L193"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andLeft\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">andLeft</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">ak</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"* `ak = .and`: `(p: A ∧ B) ⊢ A`\n* `ak = .iff`: `(p: A ↔ B) ⊢ A → B`\n* `ak = .eq`: `(p: A = B) ⊢ A → B`\n","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.andLeft","kind":"ctor","line":182,"name":"Mathlib.Tactic.ITauto.Proof.andLeft","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L182-L187"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.intro\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">intro</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p: (x: A) ⊢ B) ⊢ A → B` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.intro","kind":"ctor","line":180,"name":"Mathlib.Tactic.ITauto.Proof.intro","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L180-L181"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">exfalso'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(p: ⊥) ⊢ A` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.exfalso'","kind":"ctor","line":178,"name":"Mathlib.Tactic.ITauto.Proof.exfalso'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L178-L179"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.triv\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">triv</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`⊢ ⊤` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.triv","kind":"ctor","line":176,"name":"Mathlib.Tactic.ITauto.Proof.triv","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L176-L177"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.hyp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">hyp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Lean.Name\">Lean.Name</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`(n: A) ⊢ A` ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.hyp","kind":"ctor","line":174,"name":"Mathlib.Tactic.ITauto.Proof.hyp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L174-L175"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.sorry\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span>.<span class=\"name\">sorry</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\">Proof</a></div></div>","info":{"doc":"`⊢ A`, causes failure during reconstruction ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof.sorry","kind":"ctor","line":172,"name":"Mathlib.Tactic.ITauto.Proof.sorry","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L172-L173"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">Proof</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A reified inductive proof type for intuitionistic propositional logic. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.Proof","kind":"inductive","line":170,"name":"Mathlib.Tactic.ITauto.Proof","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L170-L235"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableLTIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instDecidableLTIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableLT\">DecidableLT</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableLTIProp","kind":"instance","line":166,"name":"Mathlib.Tactic.ITauto.instDecidableLTIProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L166-L166"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instLTIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instLTIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#LT\">LT</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instLTIProp","kind":"instance","line":164,"name":"Mathlib.Tactic.ITauto.instLTIProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L164-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></div></div>","info":{"doc":"A comparator for propositions. (There should really be a derive handler for this.) ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.cmp","kind":"def","line":148,"name":"Mathlib.Tactic.ITauto.IProp.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L148-L162"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.cmp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">cmp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p </span><span class=\"fn\">q</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Data/Ord/Basic.html#Ordering\">Ordering</a></div></div>","info":{"doc":"A comparator for `AndKind`. (There should really be a derive handler for this.) ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.cmp","kind":"def","line":143,"name":"Mathlib.Tactic.ITauto.AndKind.cmp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L143-L146"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToFormatIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Data/Format/Basic.html#Std.ToFormat\">Std.ToFormat</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToFormatIProp","kind":"instance","line":141,"name":"Mathlib.Tactic.ITauto.instToFormatIProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L141-L141"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.format\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">format</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Init/Data/Format/Basic.html#Std.Format\">Std.Format</a></span></div></div>","info":{"doc":"Debugging printer for propositions. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.format","kind":"def","line":130,"name":"Mathlib.Tactic.ITauto.IProp.format","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L130-L139"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.sides\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">sides</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></span></div></div>","info":{"doc":"Given the contents of an `And` variant, return the two conjuncts. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.sides","kind":"def","line":125,"name":"Mathlib.Tactic.ITauto.AndKind.sides","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L125-L128"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instInhabitedIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedIProp","kind":"instance","line":123,"name":"Mathlib.Tactic.ITauto.instInhabitedIProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L123-L123"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.xor\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">xor</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>","info":{"doc":"Constructor for `xor p q`. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.xor","kind":"def","line":120,"name":"Mathlib.Tactic.ITauto.IProp.xor","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L120-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.not\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">not</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>","info":{"doc":"Constructor for `¬ p`. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.not","kind":"def","line":117,"name":"Mathlib.Tactic.ITauto.IProp.not","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L117-L118"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"Constructor for `p = q`. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.eq","kind":"def","line":114,"name":"Mathlib.Tactic.ITauto.IProp.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L114-L115"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">iff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"Constructor for `p ↔ q`. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.iff","kind":"def","line":111,"name":"Mathlib.Tactic.ITauto.IProp.iff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L111-L112"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">and</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"Constructor for `p ∧ q`. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and","kind":"def","line":108,"name":"Mathlib.Tactic.ITauto.IProp.and","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L108-L109"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprIProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprIProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprIProp","kind":"instance","line":106,"name":"Mathlib.Tactic.ITauto.instToExprIProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L106-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprIProp.toExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprIProp</span>.<span class=\"name\">toExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprIProp.toExpr","kind":"def","line":106,"name":"Mathlib.Tactic.ITauto.instToExprIProp.toExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L106-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.imp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">imp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.imp","kind":"ctor","line":105,"name":"Mathlib.Tactic.ITauto.IProp.imp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L105-L105"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.or\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">or</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.or","kind":"ctor","line":104,"name":"Mathlib.Tactic.ITauto.IProp.or","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L104-L104"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and'\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">and'</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.and'","kind":"ctor","line":103,"name":"Mathlib.Tactic.ITauto.IProp.and'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L103-L103"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.false\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">false</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.false","kind":"ctor","line":102,"name":"Mathlib.Tactic.ITauto.IProp.false","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L102-L102"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.true\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">true</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.true","kind":"ctor","line":101,"name":"Mathlib.Tactic.ITauto.IProp.true","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L101-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.var\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span>.<span class=\"name\">var</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\">IProp</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp.var","kind":"ctor","line":100,"name":"Mathlib.Tactic.ITauto.IProp.var","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L100-L100"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">IProp</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A reified inductive type for propositional logic. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.IProp","kind":"inductive","line":98,"name":"Mathlib.Tactic.ITauto.IProp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L98-L106"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedAndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instInhabitedAndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instInhabitedAndKind","kind":"instance","line":96,"name":"Mathlib.Tactic.ITauto.instInhabitedAndKind","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L96-L96"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableEqAndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instDecidableEqAndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#DecidableEq\">DecidableEq</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instDecidableEqAndKind","kind":"instance","line":94,"name":"Mathlib.Tactic.ITauto.instDecidableEqAndKind","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L94-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprAndKind.toExpr\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprAndKind</span>.<span class=\"name\">toExpr</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a> → <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprAndKind.toExpr","kind":"def","line":94,"name":"Mathlib.Tactic.ITauto.instToExprAndKind.toExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L94-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprAndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">instToExprAndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/ToExpr.html#Lean.ToExpr\">Lean.ToExpr</a> <a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.instToExprAndKind","kind":"instance","line":94,"name":"Mathlib.Tactic.ITauto.instToExprAndKind","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L94-L94"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.eq\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">eq</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.eq","kind":"ctor","line":93,"name":"Mathlib.Tactic.ITauto.AndKind.eq","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L93-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.iff\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">iff</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.iff","kind":"ctor","line":93,"name":"Mathlib.Tactic.ITauto.AndKind.iff","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L93-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.and\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span>.<span class=\"name\">and</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\">AndKind</a></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind.and","kind":"ctor","line":93,"name":"Mathlib.Tactic.ITauto.AndKind.and","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L93-L93"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">ITauto</span>.<span class=\"name\">AndKind</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"Different propositional constructors that are variants of \"and\" for the purposes of the\ntheorem prover. ","docLink":"./Mathlib/Tactic/ITauto.html#Mathlib.Tactic.ITauto.AndKind","kind":"inductive","line":91,"name":"Mathlib.Tactic.ITauto.AndKind","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ITauto.lean#L91-L94"}}],"imports":["Init","Batteries.Tactic.Exact","Batteries.Tactic.Init","Mathlib.Logic.Basic","Mathlib.Util.AtomM","Qq"],"instances":[{"className":"Lean.ToExpr","name":"Mathlib.Tactic.ITauto.instToExprAndKind","typeNames":["Mathlib.Tactic.ITauto.AndKind"]},{"className":"Decidable","name":"Mathlib.Tactic.ITauto.instDecidableEqAndKind","typeNames":["Eq"]},{"className":"Inhabited","name":"Mathlib.Tactic.ITauto.instInhabitedAndKind","typeNames":["Mathlib.Tactic.ITauto.AndKind"]},{"className":"Lean.ToExpr","name":"Mathlib.Tactic.ITauto.instToExprIProp","typeNames":["Mathlib.Tactic.ITauto.IProp"]},{"className":"Inhabited","name":"Mathlib.Tactic.ITauto.instInhabitedIProp","typeNames":["Mathlib.Tactic.ITauto.IProp"]},{"className":"Std.ToFormat","name":"Mathlib.Tactic.ITauto.instToFormatIProp","typeNames":["Mathlib.Tactic.ITauto.IProp"]},{"className":"LT","name":"Mathlib.Tactic.ITauto.instLTIProp","typeNames":["Mathlib.Tactic.ITauto.IProp"]},{"className":"Decidable","name":"Mathlib.Tactic.ITauto.instDecidableLTIProp","typeNames":["LT.lt"]},{"className":"Lean.ToExpr","name":"Mathlib.Tactic.ITauto.instToExprProof","typeNames":["Mathlib.Tactic.ITauto.Proof"]},{"className":"Inhabited","name":"Mathlib.Tactic.ITauto.instInhabitedProof","typeNames":["Mathlib.Tactic.ITauto.Proof"]},{"className":"Std.ToFormat","name":"Mathlib.Tactic.ITauto.instToFormatProof","typeNames":["Mathlib.Tactic.ITauto.Proof"]},{"className":"Std.ToFormat","name":"Mathlib.Tactic.ITauto.instToFormatContext","typeNames":["Mathlib.Tactic.ITauto.Context"]}],"name":"Mathlib.Tactic.ITauto"}