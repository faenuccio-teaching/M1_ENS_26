{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Iio_ofNat\"><span class=\"name\">Finset</span>.<span class=\"name\">Iio_ofNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Simproc to compute `Finset.Iio b` where `b` is a numeral.\n\n**Warnings**:\n* With the standard depth recursion limit, this simproc can compute intervals of size 250 at most.\n* Make sure to exclude `Finset.insert_eq_of_mem` from your simp call when using this simproc. This\n  avoids a quadratic time performance hit. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Iio_ofNat","kind":"def","line":242,"name":"Finset.Iio_ofNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L242-L261"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Iic_ofNat\"><span class=\"name\">Finset</span>.<span class=\"name\">Iic_ofNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Simproc to compute `Finset.Iic b` where `b` is a numeral.\n\n**Warnings**:\n* With the standard depth recursion limit, this simproc can compute intervals of size 250 at most.\n* Make sure to exclude `Finset.insert_eq_of_mem` from your simp call when using this simproc. This\n  avoids a quadratic time performance hit. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Iic_ofNat","kind":"def","line":228,"name":"Finset.Iic_ofNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L228-L240"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Ioo_ofNat_ofNat\"><span class=\"name\">Finset</span>.<span class=\"name\">Ioo_ofNat_ofNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Simproc to compute `Finset.Ioo a b` where `a` and `b` are numerals.\n\n**Warnings**:\n* With the standard depth recursion limit, this simproc can compute intervals of size 250 at most.\n* Make sure to exclude `Finset.insert_eq_of_mem` from your simp call when using this simproc. This\n  avoids a quadratic time performance hit. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Ioo_ofNat_ofNat","kind":"def","line":204,"name":"Finset.Ioo_ofNat_ofNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L204-L226"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Ioc_ofNat_ofNat\"><span class=\"name\">Finset</span>.<span class=\"name\">Ioc_ofNat_ofNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Simproc to compute `Finset.Ioc a b` where `a` and `b` are numerals.\n\n**Warnings**:\n* With the standard depth recursion limit, this simproc can compute intervals of size 250 at most.\n* Make sure to exclude `Finset.insert_eq_of_mem` from your simp call when using this simproc. This\n  avoids a quadratic time performance hit. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Ioc_ofNat_ofNat","kind":"def","line":180,"name":"Finset.Ioc_ofNat_ofNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L180-L202"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Ico_ofNat_ofNat\"><span class=\"name\">Finset</span>.<span class=\"name\">Ico_ofNat_ofNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Simproc to compute `Finset.Ico a b` where `a` and `b` are numerals.\n\n**Warnings**:\n* With the standard depth recursion limit, this simproc can compute intervals of size 250 at most.\n* Make sure to exclude `Finset.insert_eq_of_mem` from your simp call when using this simproc. This\n  avoids a quadratic time performance hit. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Ico_ofNat_ofNat","kind":"def","line":151,"name":"Finset.Ico_ofNat_ofNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L151-L178"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Icc_ofNat_ofNat\"><span class=\"name\">Finset</span>.<span class=\"name\">Icc_ofNat_ofNat</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Simproc\">Lean.Meta.Simp.Simproc</a></div></div>","info":{"doc":"Simproc to compute `Finset.Icc a b` where `a` and `b` are numerals.\n\n**Warnings**:\n* With the standard depth recursion limit, this simproc can compute intervals of size 250 at most.\n* Make sure to exclude `Finset.insert_eq_of_mem` from your simp call when using this simproc. This\n  avoids a quadratic time performance hit. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Finset.Icc_ofNat_ofNat","kind":"def","line":131,"name":"Finset.Icc_ofNat_ofNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L131-L149"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Mathlib.Tactic.Simp.evalFinsetIccInt\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Simp</span>.<span class=\"name\">evalFinsetIccInt</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m </span><span class=\"fn\">n</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">em </span><span class=\"fn\">en</span> : <span class=\"fn\">Q(<a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">((<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a></span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Interval/Finset/Defs.html#Finset.Icc\">Finset.Icc</a> <span class=\"fn\">«$em»</span> <span class=\"fn\">«$en»</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$s»</span>)</span>)</span></span></div></div>","info":{"doc":"Given integers `m` and `n` and corresponding integer literals `em` and `en`,\nreturns `(s, ⊢ Finset.Icc m n = s)`.\n\nThis cannot be easily merged with `evalFinsetIccNat` since they require different\nhandling of numerals for `ℕ` and `ℤ`. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Mathlib.Tactic.Simp.evalFinsetIccInt","kind":"opaque","line":97,"name":"Mathlib.Tactic.Simp.evalFinsetIccInt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L97-L119"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/Simproc/FinsetInterval.html#Mathlib.Tactic.Simp.evalFinsetIccNat\"><span class=\"name\">Mathlib</span>.<span class=\"name\">Tactic</span>.<span class=\"name\">Simp</span>.<span class=\"name\">evalFinsetIccNat</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m </span><span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">em </span><span class=\"fn\">en</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">((<span class=\"fn\">s</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Data/Finset/Defs.html#Finset\">Finset</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span>)</span>) × <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Order/Interval/Finset/Defs.html#Finset.Icc\">Finset.Icc</a> <span class=\"fn\">«$em»</span> <span class=\"fn\">«$en»</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">«$s»</span>)</span>)</span></span></div></div>","info":{"doc":"Given natural numbers `m` and `n` and corresponding natural literals `em` and `en`,\nreturns `(s, ⊢ Finset.Icc m n = s)`.\n\nThis cannot be easily merged with `evalFinsetIccInt` since they require different\nhandling of numerals for `ℕ` and `ℤ`. ","docLink":"./Mathlib/Tactic/Simproc/FinsetInterval.html#Mathlib.Tactic.Simp.evalFinsetIccNat","kind":"def","line":73,"name":"Mathlib.Tactic.Simp.evalFinsetIccNat","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/Simproc/FinsetInterval.lean#L73-L95"}}],"imports":["Init","Mathlib.Algebra.Order.Interval.Finset.SuccPred","Mathlib.Data.Nat.SuccPred","Mathlib.Data.Int.Interval","Mathlib.Data.Int.SuccPred","Mathlib.Order.Interval.Finset.Nat","Mathlib.Util.Qq"],"instances":[],"name":"Mathlib.Tactic.Simproc.FinsetInterval"}