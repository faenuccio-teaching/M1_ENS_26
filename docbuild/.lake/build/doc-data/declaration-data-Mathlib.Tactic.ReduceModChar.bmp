{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char!\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduce_mod_char!</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The tactic `reduce_mod_char` looks for numeric expressions in characteristic `p`\nand reduces these to lie between `0` and `p`.\n\nFor example:\n```\nexample : (5 : ZMod 4) = 1 := by reduce_mod_char\nexample : (X ^ 2 - 3 * X + 4 : (ZMod 4)[X]) = X ^ 2 + X := by reduce_mod_char\n```\n\nIt also handles negation, turning it into multiplication by `p - 1`,\nand similarly subtraction.\n\nThis tactic uses the type of the subexpression to figure out if it is indeed of positive\ncharacteristic, for improved performance compared to trying to synthesise a `CharP` instance.\nThe variant `reduce_mod_char!` also tries to use `CharP R n` hypotheses in the context.\n(Limitations of the typeclass system mean the tactic can't search for a `CharP R n` instance if\n`n` is not yet known; use `have : CharP R n := inferInstance; reduce_mod_char!` as a workaround.)\n","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char!","kind":"def","line":292,"name":"Tactic.ReduceModChar.reduce_mod_char!","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L292-L293"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">reduce_mod_char</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"The tactic `reduce_mod_char` looks for numeric expressions in characteristic `p`\nand reduces these to lie between `0` and `p`.\n\nFor example:\n```\nexample : (5 : ZMod 4) = 1 := by reduce_mod_char\nexample : (X ^ 2 - 3 * X + 4 : (ZMod 4)[X]) = X ^ 2 + X := by reduce_mod_char\n```\n\nIt also handles negation, turning it into multiplication by `p - 1`,\nand similarly subtraction.\n\nThis tactic uses the type of the subexpression to figure out if it is indeed of positive\ncharacteristic, for improved performance compared to trying to synthesise a `CharP` instance.\nThe variant `reduce_mod_char!` also tries to use `CharP R n` hypotheses in the context.\n(Limitations of the typeclass system mean the tactic can't search for a `CharP R n` instance if\n`n` is not yet known; use `have : CharP R n := inferInstance; reduce_mod_char!` as a workaround.)\n","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.reduce_mod_char","kind":"def","line":272,"name":"Tactic.ReduceModChar.reduce_mod_char","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L272-L291"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.derive\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">derive</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Reduce all numeric subexpressions of `e` modulo their characteristic.\n\nUse `derive (expensive := true)` to do more work in finding the characteristic of\nthe type of `e`.\n","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.derive","kind":"def","line":237,"name":"Tactic.ReduceModChar.derive","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L237-L268"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.matchAndNorm\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">matchAndNorm</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given an expression `e`, determine whether it is a numeric expression in characteristic `n`,\nand if so, reduce `e` modulo `n`.\n\nThis is not a `norm_num` plugin because it does not match on the syntax of `e`,\nrather it matches on the type of `e`.\n\nUse `matchAndNorm (expensive := true)` to do more work in finding the characteristic of\nthe type of `e`.\n","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.matchAndNorm","kind":"def","line":203,"name":"Tactic.ReduceModChar.matchAndNorm","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L203-L230"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.typeToCharP\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">typeToCharP</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">expensive</span> : <a href=\"./Init/Prelude.html#Bool\">Bool</a> := <a href=\"./Init/Prelude.html#Bool.false\">false</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">t</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">t</span>)</span></span></div></div>","info":{"doc":"Determine the characteristic of a ring from the type.\nThis should be fast, so this pattern-matches on the type, rather than searching for a\n`CharP` instance.\nUse `typeToCharP (expensive := true)` to do more work in finding the characteristic,\nin particular it will search for a `CharP` instance in the context. ","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.typeToCharP","kind":"opaque","line":174,"name":"Tactic.ReduceModChar.typeToCharP","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L174-L201"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">instance</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.instInhabitedTypeToCharPResult\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">instInhabitedTypeToCharPResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Inhabited\">Inhabited</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">α</span>)</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.instInhabitedTypeToCharPResult","kind":"instance","line":172,"name":"Tactic.ReduceModChar.instInhabitedTypeToCharPResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L172-L172"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.failure\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span>.<span class=\"name\">failure</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.failure","kind":"ctor","line":170,"name":"Tactic.ReduceModChar.TypeToCharPResult.failure","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L170-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.intLike\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span>.<span class=\"name\">intLike</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instRing</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\">TypeToCharPResult</a> <span class=\"fn\">α</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult.intLike","kind":"ctor","line":169,"name":"Tactic.ReduceModChar.TypeToCharPResult.intLike","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L169-L169"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">inductive</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">TypeToCharPResult</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"A `TypeToCharPResult α` indicates if `α` can be determined to be a ring of characteristic `p`.\n","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.TypeToCharPResult","kind":"inductive","line":166,"name":"Tactic.ReduceModChar.TypeToCharPResult","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L166-L170"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNegCoeffMul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normNegCoeffMul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_instRing</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given an expression `-(a * b) : t` such that `t` is a ring of characteristic `n`,\nand `a` is a numeral, simplify this to `((n - 1) * a) * b`. ","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNegCoeffMul","kind":"def","line":145,"name":"Tactic.ReduceModChar.normNegCoeffMul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L145-L164"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">neg_mul_eq_sub_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a </span><span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">na</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">na'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> ((<span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span>) <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">a</span>) <span class=\"fn\">na</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pa</span> : <span class=\"fn\">↑<span class=\"fn\">na</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">na'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a>(<span class=\"fn\">a</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span>) <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">na'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul","kind":"theorem","line":139,"name":"Tactic.ReduceModChar.CharP.neg_mul_eq_sub_one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L139-L143"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNeg\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normNeg</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">_instRing</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Given an expression `(-e) : t` such that `t` is a ring of characteristic `n`,\nsimplify this to `(n - 1) * e`.\n\nThis should be called only when `normIntNumeral` fails, because `normIntNumeral` would otherwise\nbe more useful by evaluating `-e` mod `n` to an actual numeral.\n","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normNeg","kind":"def","line":116,"name":"Tactic.ReduceModChar.normNeg","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L116-L137"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">neg_eq_sub_one_mul</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">b</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">a'</span> : <span class=\"fn\">α</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> (<span class=\"fn\">↑<span class=\"fn\">n</span></span> <a href=\"./Init/Prelude.html#HSub.hSub\">-</a> <span class=\"fn\">1</span>) <span class=\"fn\">a</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pa</span> : <span class=\"fn\">↑<span class=\"fn\">a</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Neg.neg\">-</a><span class=\"fn\">b</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">a'</span> <a href=\"./Init/Prelude.html#HMul.hMul\">*</a> <span class=\"fn\">b</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul","kind":"theorem","line":110,"name":"Tactic.ReduceModChar.CharP.neg_eq_sub_one_mul","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L110-L114"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normIntNumeral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Given an integral expression `e : t` such that `t` is a ring of characteristic `n`,\nreduce `e` modulo `n`. ","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral","kind":"def","line":103,"name":"Tactic.ReduceModChar.normIntNumeral","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L103-L108"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.intCast_eq_mod\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">intCast_eq_mod</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">R</span> : <a href=\"./foundational_types.html\">Type</a> u_1)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">R</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">p</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">R</span> <span class=\"fn\">p</span></span>]</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">↑<span class=\"fn\">k</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">↑(<span class=\"fn\">k</span> <a href=\"./Init/Prelude.html#HMod.hMod\">%</a> <span class=\"fn\">↑<span class=\"fn\">p</span></span>)</span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.intCast_eq_mod","kind":"theorem","line":99,"name":"Tactic.ReduceModChar.CharP.intCast_eq_mod","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L99-L101"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral'\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normIntNumeral'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$n'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"If `e` is of the form `a ^ b`, reduce it using fast modular exponentiation, otherwise\nreduce it using `norm_num`. ","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normIntNumeral'","kind":"opaque","line":91,"name":"Tactic.ReduceModChar.normIntNumeral'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L91-L95"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">partial def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normPow\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normPow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$n'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Given an expression of the form `a ^ b` in a ring of characteristic `n`, reduces `a`\nmodulo `n` recursively and then calculates `a ^ b` using fast modular exponentiation. ","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normPow","kind":"opaque","line":77,"name":"Tactic.ReduceModChar.normPow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L77-L89"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normBareNumeral\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">normBareNumeral</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">u</span> : <a href=\"./Lean/Level.html#Lean.Level\">Lean.Level</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <span class=\"fn\">Q(<a href=\"./foundational_types.html\">Type</a> u)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pn</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">«$n»</span> <span class=\"fn\">«$n'»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <span class=\"fn\">Q(<span class=\"fn\">«$α»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">x✝</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">«$α»</span></span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">instCharP</span> : <span class=\"fn\">Q(<span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">«$α»</span> <span class=\"fn\">«$n»</span></span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.Result\">Mathlib.Meta.NormNum.Result</a> <span class=\"fn\">e</span>)</span></span></div></div>","info":{"doc":"Evaluates `e` to an integer using `norm_num` and reduces the result modulo `n`. ","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.normBareNumeral","kind":"def","line":66,"name":"Tactic.ReduceModChar.normBareNumeral","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L66-L73"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isNat_pow\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">isNat_pow</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Semiring\">Semiring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f</span> : <span class=\"fn\"><span class=\"fn\">α</span> → <span class=\"fn\"><a href=\"./Init/Prelude.html#Nat\">ℕ</a> → <span class=\"fn\">α</span></span></span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">a' </span><span class=\"fn\">b </span><span class=\"fn\">b' </span><span class=\"fn\">c </span><span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span> →\n  <span class=\"fn\"><span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <a href=\"./Init/Prelude.html#HPow.hPow\">HPow.hPow</a> →\n    <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">a</span> <span class=\"fn\">a'</span></span> →\n      <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">b</span> <span class=\"fn\">b'</span></span> →\n        <span class=\"fn\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span> → <span class=\"fn\"><span class=\"fn\"><span class=\"fn\"><span class=\"fn\">(<span class=\"fn\"><span class=\"fn\">a'</span>.<a href=\"./Init/Prelude.html#Nat.pow\">pow</a></span> <span class=\"fn\">b'</span>)</span>.<a href=\"./Init/Prelude.html#Nat.mod\">mod</a></span> <span class=\"fn\">n'</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">c</span> → <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">(<span class=\"fn\">f</span> <span class=\"fn\">a</span> <span class=\"fn\">b</span>)</span> <span class=\"fn\">c</span></span></span></span></span></span></span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isNat_pow","kind":"theorem","line":58,"name":"Tactic.ReduceModChar.CharP.isNat_pow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L58-L63"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isInt_of_mod\"><span class=\"name\">Tactic</span>.<span class=\"name\">ReduceModChar</span>.<span class=\"name\">CharP</span>.<span class=\"name\">isInt_of_mod</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e' </span><span class=\"fn\">r</span> : <a href=\"./Init/Data/Int/Basic.html#Int\">ℤ</a>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">α</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/Algebra/Ring/Defs.html#Ring\">Ring</a> <span class=\"fn\">α</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">n </span><span class=\"fn\">n'</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">inst</span> : <span class=\"fn\"><a href=\"./Mathlib/Algebra/CharP/Defs.html#CharP\">CharP</a> <span class=\"fn\">α</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">e</span> : <span class=\"fn\">α</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">he</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">e</span> <span class=\"fn\">e'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">hn</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsNat\">Mathlib.Meta.NormNum.IsNat</a> <span class=\"fn\">n</span> <span class=\"fn\">n'</span></span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h₂</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> (<span class=\"fn\">e'</span> <a href=\"./Init/Prelude.html#HMod.hMod\">%</a> <span class=\"fn\">↑<span class=\"fn\">n'</span></span>) <span class=\"fn\">r</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Result.html#Mathlib.Meta.NormNum.IsInt\">Mathlib.Meta.NormNum.IsInt</a> <span class=\"fn\">e</span> <span class=\"fn\">r</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/ReduceModChar.html#Tactic.ReduceModChar.CharP.isInt_of_mod","kind":"theorem","line":54,"name":"Tactic.ReduceModChar.CharP.isInt_of_mod","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/ReduceModChar.lean#L54-L56"}}],"imports":["Init","Mathlib.Data.ZMod.Basic","Mathlib.RingTheory.Polynomial.Basic","Mathlib.Tactic.NormNum.DivMod","Mathlib.Tactic.NormNum.PowMod","Mathlib.Tactic.ReduceModChar.Ext","Mathlib.Util.AtLocation","Mathlib.Tactic.NormNum.DivMod"],"instances":[{"className":"Inhabited","name":"Tactic.ReduceModChar.instInhabitedTypeToCharPResult","typeNames":["Tactic.ReduceModChar.TypeToCharPResult"]}],"name":"Mathlib.Tactic.ReduceModChar"}