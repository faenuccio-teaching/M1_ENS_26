{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.evalIrrationalSqrt\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalIrrationalSqrt</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt\">Mathlib.Meta.NormNum.NormNumExt</a></div></div>","info":{"doc":"`norm_num` extension that proves `Irrational √x` for rational `x`. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.evalIrrationalSqrt","kind":"def","line":324,"name":"Tactic.NormNum.evalIrrationalSqrt","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L324-L349"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.evalIrrationalRpow\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">evalIrrationalRpow</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Mathlib/Tactic/NormNum/Core.html#Mathlib.Meta.NormNum.NormNumExt\">Mathlib.Meta.NormNum.NormNumExt</a></div></div>","info":{"doc":"`norm_num` extension that proves `Irrational x ^ y` for rational `y`. `x` may be\nnatural or rational. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.evalIrrationalRpow","kind":"def","line":289,"name":"Tactic.NormNum.evalIrrationalRpow","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L289-L322"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.findNotPowerCertificate\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">findNotPowerCertificate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m </span><span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <span class=\"fn\">(<a href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate\">NotPowerCertificate</a> <span class=\"fn\">m</span> <span class=\"fn\">n</span>)</span></span></div></div>","info":{"doc":"Finds `NotPowerCertificate` showing that `m` is not `n`-power. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.findNotPowerCertificate","kind":"def","line":278,"name":"Tactic.NormNum.findNotPowerCertificate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L278-L287"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.findNotPowerCertificateCore\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">findNotPowerCertificateCore</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m </span><span class=\"fn\">n</span> : <a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/Prelude.html#Option\">Option</a> <a href=\"./Init/Prelude.html#Nat\">ℕ</a></span></div></div>","info":{"doc":"Finds `k` such that `k ^ n < m < (k + 1) ^ n` using bisection method. It assumes `n > 0`. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.findNotPowerCertificateCore","kind":"def","line":264,"name":"Tactic.NormNum.findNotPowerCertificateCore","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L264-L276"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.pf_right\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">NotPowerCertificate</span>.<span class=\"name\">pf_right</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m </span><span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate\">NotPowerCertificate</a> <span class=\"fn\">m</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">«$m»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> (<span class=\"fn\">unknown_1</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$n»</span>)</span></div></div>","info":{"doc":"Proof of `m < (k + 1) ^ n`. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.pf_right","kind":"def","line":262,"name":"Tactic.NormNum.NotPowerCertificate.pf_right","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L262-L262"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.pf_left\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">NotPowerCertificate</span>.<span class=\"name\">pf_left</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m </span><span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate\">NotPowerCertificate</a> <span class=\"fn\">m</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<span class=\"fn\">unknown_1</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$n»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$m»</span>)</span></div></div>","info":{"doc":"Proof of `k ^ n < m`. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.pf_left","kind":"def","line":260,"name":"Tactic.NormNum.NotPowerCertificate.pf_left","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L260-L260"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">abbrev</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.k\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">NotPowerCertificate</span>.<span class=\"name\">k</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m </span><span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">self</span> : <span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate\">NotPowerCertificate</a> <span class=\"fn\">m</span> <span class=\"fn\">n</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span></div></div>","info":{"doc":"Natural `k` such that `k ^ n < m < (k + 1) ^ n`. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.k","kind":"def","line":258,"name":"Tactic.NormNum.NotPowerCertificate.k","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L258-L258"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">constructor</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.mk\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">NotPowerCertificate</span>.<span class=\"name\">mk</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">m </span><span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">k</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf_left</span> : <span class=\"fn\">Q(<span class=\"fn\">«$k»</span> <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$n»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> <span class=\"fn\">«$m»</span>)</span>)</span></span>\n<span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf_right</span> : <span class=\"fn\">Q(<span class=\"fn\">«$m»</span> <a href=\"./Init/Prelude.html#LT.lt\">&lt;</a> (<span class=\"fn\">«$k»</span> <a href=\"./Init/Prelude.html#HAdd.hAdd\">+</a> <span class=\"fn\">1</span>) <a href=\"./Init/Prelude.html#HPow.hPow\">^</a> <span class=\"fn\">«$n»</span>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate\">NotPowerCertificate</a> <span class=\"fn\">m</span> <span class=\"fn\">n</span></span></div></div>","info":{"doc":"","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate.mk","kind":"ctor","line":256,"name":"Tactic.NormNum.NotPowerCertificate.mk","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L256-L256"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">structure</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate\"><span class=\"name\">Tactic</span>.<span class=\"name\">NormNum</span>.<span class=\"name\">NotPowerCertificate</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">m </span><span class=\"fn\">n</span> : <span class=\"fn\">Q(<a href=\"./Init/Prelude.html#Nat\">ℕ</a>)</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./foundational_types.html\">Type</a></div></div>","info":{"doc":"To prove that `m` is not `n`-power (and thus `m ^ (1/n)` is irrational), we find `k` such that\n`k ^ n < m < (k + 1) ^ n`. ","docLink":"./Mathlib/Tactic/NormNum/Irrational.html#Tactic.NormNum.NotPowerCertificate","kind":"structure","line":254,"name":"Tactic.NormNum.NotPowerCertificate","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/NormNum/Irrational.lean#L254-L262"}}],"imports":["Init","Mathlib.Analysis.SpecialFunctions.Pow.Real","Mathlib.NumberTheory.Real.Irrational","Mathlib.Tactic.NormNum.GCD","Mathlib.Tactic.Rify"],"instances":[],"name":"Mathlib.Tactic.NormNum.Irrational"}