{"declarations":[{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.«termReassoc_of%_»\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">«termReassoc_of%_»</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"`reassoc_of% t`, where `t` is\nan equation `f = g` between morphisms `X ⟶ Y` in a category (possibly after a `∀` binder),\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\nThis also works for equations between isomorphisms, provided that\n`Tactic.CategoryTheory.IsoReassoc` has been imported.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.«termReassoc_of%_»","kind":"def","line":148,"name":"CategoryTheory.«termReassoc_of%_»","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L148-L158"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassocExpr'</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Elab/Term/TermElabM.html#Lean.Elab.Term.TermElabM\">Lean.Elab.TermElabM</a> <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a></span></div></div>","info":{"doc":"Version of `reassocExpr` for the `TermElabM` monad. Handles instance metavariables automatically.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr'","kind":"def","line":123,"name":"CategoryTheory.reassocExpr'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L123-L132"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassocExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">pf</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>","info":{"doc":"Reassociates the morphisms in the type of `pf` using the registered handlers,\nusing `reassocExprHom` as the default.\n\nReturns the proof of the lemma along with instance metavariables that need synthesis.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExpr","kind":"def","line":109,"name":"CategoryTheory.reassocExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L109-L121"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.registerReassocExpr\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">registerReassocExpr</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">f</span> : <span class=\"fn\"><a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> → <span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Init/System/IO.html#IO\">IO</a> <a href=\"./Init/Prelude.html#Unit\">Unit</a></span></div></div>","info":{"doc":"Registers a handler for `reassocExpr`. The handler takes a proof of an equation\nand returns a proof of the reassociation lemma.\nHandlers are considered in order of registration.\nThey are applied directly to the equation in the body of the forall.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.registerReassocExpr","kind":"def","line":100,"name":"CategoryTheory.registerReassocExpr","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L100-L107"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassoc\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassoc</span></a></span><span class=\"decl_args\"> :</span><div class=\"decl_type\"><a href=\"./Init/Prelude.html#Lean.ParserDescr\">Lean.ParserDescr</a></div></div>","info":{"doc":"Adding `@[reassoc]` to a lemma named `F` of shape `∀ .., f = g`, where `f g : X ⟶ Y` are\nmorphisms in some category, will create a new lemma named `F_assoc` of shape\n`∀ .. {Z : C} (h : Y ⟶ Z), f ≫ h = g ≫ h`\nbut with the conclusions simplified using the axioms for a category\n(`Category.comp_id`, `Category.id_comp`, and `Category.assoc`).\nSo, for example, if the conclusion of `F` is `a ≫ b = g` then\nthe conclusion of `F_assoc` will be `a ≫ (b ≫ h) = g ≫ h` (note that `≫` reassociates\nto the right so the brackets will not appear in the statement).\n\nThis attribute is useful for generating lemmas which the simplifier can use even on expressions\nthat are already right associated.\n\nNote that if you want both the lemma and the reassociated lemma to be\n`simp` lemmas, you should tag the lemma `@[reassoc (attr := simp)]`.\nThe variant `@[simp, reassoc]` on a lemma `F` will tag `F` with `@[simp]`,\nbut not `F_assoc` (this is sometimes useful).\n\nThis attribute also works for lemmas of shape `∀ .., f = g` where `f g : X ≅ Y` are\nisomorphisms, provided that `Tactic.CategoryTheory.IsoReassoc` has been imported.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassoc","kind":"def","line":67,"name":"CategoryTheory.reassoc","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L67-L88"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExprHom\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">reassocExprHom</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> (<a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a> <a href=\"./Init/Prelude.html#Prod\">×</a> <span class=\"fn\"><a href=\"./Init/Prelude.html#Array\">Array</a> <a href=\"./Lean/Expr.html#Lean.MVarId\">Lean.MVarId</a></span>)</span></div></div>","info":{"doc":"Given an equation `f = g` between morphisms `X ⟶ Y` in a category,\nproduce the equation `∀ {Z} (h : Y ⟶ Z), f ≫ h = g ≫ h`,\nbut with compositions fully right associated and identities removed.\nAlso returns the category `C` and any instance metavariables that need to be solved for.\n","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.reassocExprHom","kind":"def","line":51,"name":"CategoryTheory.reassocExprHom","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L51-L65"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">def</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.categorySimp\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">categorySimp</span></a></span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">e</span> : <a href=\"./Lean/Expr.html#Lean.Expr\">Lean.Expr</a>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Lean/Meta/Basic.html#Lean.Meta.MetaM\">Lean.MetaM</a> <a href=\"./Lean/Meta/Tactic/Simp/Types.html#Lean.Meta.Simp.Result\">Lean.Meta.Simp.Result</a></span></div></div>","info":{"doc":"Simplify an expression using only the axioms of a category. ","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.categorySimp","kind":"def","line":45,"name":"CategoryTheory.categorySimp","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L45-L49"}},{"header":"<div class=\"decl_header\"><span class=\"decl_kind\">theorem</span>\n<span class=\"decl_name\"><a class=\"break_within\" href=\"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.eq_whisker'\"><span class=\"name\">CategoryTheory</span>.<span class=\"name\">eq_whisker'</span></a></span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">C</span> : <a href=\"./foundational_types.html\">Type</a> u_1}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">[<span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.Category\">Category.{v_1, u_1}</a> <span class=\"fn\">C</span></span>]</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">X </span><span class=\"fn\">Y</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">f </span><span class=\"fn\">g</span> : <span class=\"fn\">X</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Y</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">w</span> : <span class=\"fn\">f</span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\">g</span>)</span></span>\n<span class=\"impl_arg\"><span class=\"decl_args\">\n<span class=\"fn\">{<span class=\"fn\">Z</span> : <span class=\"fn\">C</span>}</span></span>\n</span><span class=\"decl_args\">\n<span class=\"fn\">(<span class=\"fn\">h</span> : <span class=\"fn\">Y</span> <a href=\"./Mathlib/Combinatorics/Quiver/Basic.html#Quiver.Hom\">⟶</a> <span class=\"fn\">Z</span>)</span></span>\n<span class=\"decl_args\"> :</span><div class=\"decl_type\"><span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">f</span> <span class=\"fn\">h</span></span> <a href=\"./Init/Prelude.html#Eq\">=</a> <span class=\"fn\"><a href=\"./Mathlib/CategoryTheory/Category/Basic.html#CategoryTheory.CategoryStruct.comp\">CategoryStruct.comp</a> <span class=\"fn\">g</span> <span class=\"fn\">h</span></span></div></div>","info":{"doc":"A variant of `eq_whisker` with a more convenient argument order for use in tactics. ","docLink":"./Mathlib/Tactic/CategoryTheory/Reassoc.html#CategoryTheory.eq_whisker'","kind":"theorem","line":40,"name":"CategoryTheory.eq_whisker'","sourceLink":"https://github.com/leanprover-community/mathlib4/blob/32d24245c7a12ded17325299fd41d412022cd3fe/Mathlib/Tactic/CategoryTheory/Reassoc.lean#L40-L43"}}],"imports":["Init","Mathlib.CategoryTheory.Functor.Basic","Mathlib.CategoryTheory.Functor.Basic","Mathlib.Lean.Meta.Simp","Mathlib.Tactic.Simps.Basic","Mathlib.Util.AddRelatedDecl"],"instances":[],"name":"Mathlib.Tactic.CategoryTheory.Reassoc"}